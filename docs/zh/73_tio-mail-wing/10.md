# 任务3：实现 IMAP 服务
IMAP 的实现会比前两者复杂得多，因为它是有状态的、功能丰富的，并且响应格式也更多样。我们将采用“最小可用”的策略，先实现能让主流客户端连接并收发邮件的核心功能。
## IMAP 协议详解 (Internet Message Access Protocol)

IMAP，全称为“互联网消息访问协议”，是与 POP3 并列的另一种主流邮件读取协议。与 POP3 的“下载并删除”模式截然不同，IMAP 的核心思想是**将邮件保留在服务器上，客户端的操作都是对服务器上邮件的远程操作**。

**核心思想：** 你的所有邮件都存放在一个远程的、永远在线的“云端文件柜”里。你可以用电脑、手机、平板等任何设备去查看和管理这个文件柜里的文件（邮件）。你在电脑上把一封邮件标记为已读，手机上会立刻同步看到这个已读状态。你在手机上删了一封邮件，电脑上这封邮件也消失了。

---

### 主要特点

1.  **服务器端存储 (Server-Side Storage)**：
    所有邮件和文件夹都存储在服务器上。这使得用户可以从多个不同的设备访问自己的所有邮件。

2.  **多设备同步 (Excellent for Multi-Device Sync)**：
    IMAP 的核心优势。你在任何一个客户端上的操作（如已读、删除、移动到文件夹）都会被同步到服务器，其他所有客户端都能看到这些变化。

3.  **状态化协议 (Stateful Protocol)**：
    客户端可以获取邮件的状态信息（如是否已读、是否被回复、是否被标记），并可以只修改状态而不必下载整个邮件。

4.  **选择性下载 (Selective Download)**：
    客户端可以只下载邮件头（发件人、主题），或者只下载邮件的正文部分，甚至可以只下载附件，而不需要一次性把整个邮件都取回。这在移动网络环境下非常高效。

5.  **文件夹管理 (Mailbox Management)**：
    IMAP 原生支持在服务器上创建、删除、重命名多个邮箱文件夹（Mailboxes），方便用户对邮件进行分类管理。

6.  **复杂性 (Complexity)**：
    为了实现上述强大功能，IMAP 协议本身比 POP3 和 SMTP 复杂得多。它的命令集更大，响应格式也更丰富，包括“无标签”的服务器推送数据。

---

### IMAP 会话的三个阶段

1.  **未认证 (Not Authenticated) 状态**
    *   客户端刚连接上服务器。
    *   **目标**：登录。
    *   **可用命令**：`CAPABILITY` (查询服务器能力), `LOGIN` (登录), `STARTTLS` (启动加密), `AUTHENTICATE`。
    *   **状态转换**：`LOGIN` 成功后，进入 **已认证** 状态。

2.  **已认证 (Authenticated) 状态**
    *   客户端已成功登录，但还未选择要操作的邮箱。
    *   **目标**：选择一个邮箱进行操作。
    *   **可用命令**：`SELECT` (选择邮箱), `EXAMINE` (以只读方式选择邮箱), `LIST` (列出所有邮箱), `CREATE` (创建邮箱), `LOGOUT` (登出) 等。
    *   **状态转换**：`SELECT` 或 `EXAMINE` 成功后，进入 **已选择** 状态。`LOGOUT` 后会话结束。

3.  **已选择 (Selected) 状态**
    *   客户端已选择了一个邮箱（如 `INBOX`），这是进行邮件操作的核心状态。
    *   **目标**：读取和管理邮件。
    *   **可用命令**：`FETCH` (获取邮件内容), `STORE` (修改邮件标志), `COPY` (复制邮件), `UID` (使用唯一标识符操作邮件), `CLOSE` (关闭当前邮箱), `LOGOUT` 等。
    *   **状态转换**：`CLOSE` 后返回 **已认证** 状态。`LOGOUT` 后会话结束。

### IMAP 命令与响应的特点

*   **命令标签 (Tag)**: 客户端发出的每个命令都必须以一个唯一的标签（Tag）开头，如 `A001`, `A002`。
*   **响应**:
    *   **带标签的完成响应 (Tagged Responses)**: 服务器对命令的最终响应，使用与命令相同的标签，并以 `OK` (成功), `NO` (失败，但命令合法), `BAD` (命令语法错误) 结尾。
    *   **无标签的数据响应 (Untagged Responses)**: 服务器主动发送的数据，以 `*` 开头。例如，`FETCH` 命令会返回 `* 1 FETCH (...)` 的数据，`SELECT` 命令会返回 `* 3 EXISTS` 这样的邮箱状态。
    *   **持续响应 (Continuation Responses)**: 以 `+` 开头，表示服务器等待客户端输入更多信息。

---

### 常用 IMAP 命令详解 (MVP)

| 命令 | 格式 | 作用 | 示例 | 可能的响应 |
| :--- | :--- | :--- | :--- | :--- |
| **CAPABILITY** | `tag CAPABILITY` | 获取服务器能力 | `A001 CAPABILITY` | `* CAPABILITY IMAP4rev1 AUTH=LOGIN ...\r\nA001 OK` |
| **LOGIN** | `tag LOGIN <user> <pass>` | 用户登录 | `A002 LOGIN u@t.com p` | `A002 OK Login successful` |
| **LOGOUT** | `tag LOGOUT` | 登出 | `A003 LOGOUT` | `* BYE Logging out\r\nA003 OK` |
| **LIST** | `tag LIST <ref> <pattern>` | 列出邮箱 | `A004 LIST "" "*"` | `* LIST () "/" INBOX\r\nA004 OK` |
| **SELECT** | `tag SELECT <mailbox>` | 选择邮箱 | `A005 SELECT INBOX` | `* 2 EXISTS\r\n* FLAGS (..)\r\nA005 OK [READ-WRITE]` |
| **FETCH** | `tag FETCH <set> <items>` | 获取邮件信息 | `A006 FETCH 1 (BODY[])` | `* 1 FETCH (BODY[] {size}\r\n...)\r\nA006 OK` |
| **STORE** | `tag STORE <set> <op> <flags>` | 修改邮件标志 | `A007 STORE 1 +FLAGS (\Seen)` | `* 1 FETCH (FLAGS (\Seen))\r\nA007 OK` |
| **NOOP** | `tag NOOP` | 无操作（心跳） | `A008 NOOP` | `A008 OK` |

---

### 一个完整的 Telnet 交互示例

```
# 1. 连接到服务器的 143 端口
$ telnet localhost 143

# 2. 服务器返回欢迎信息，进入【未认证】状态
S: * OK tio-mail-wing IMAP4rev1 server ready

# 3. 客户端查询服务器能力
C: A001 CAPABILITY
S: * CAPABILITY IMAP4rev1 AUTH=LOGIN
S: A001 OK CAPABILITY completed

# 4. 客户端登录
C: A002 LOGIN user1@tio.com pass1
S: A002 OK LOGIN completed

# 5. 客户端列出所有邮箱，进入【已认证】状态
C: A003 LIST "" "*"
S: * LIST (\HasNoChildren) "/" INBOX
S: A003 OK LIST completed

# 6. 客户端选择 INBOX 邮箱，进入【已选择】状态
C: A004 SELECT INBOX
S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
S: * 2 EXISTS
S: * 2 RECENT
S: * OK [UNSEEN 1] First unseen.
S: * OK [UIDVALIDITY 1] UIDs valid.
S: A004 OK [READ-WRITE] SELECT completed.

# 7. 客户端获取第一封邮件的头部信息
C: A005 FETCH 1 (BODY.PEEK[HEADER])
S: * 1 FETCH (BODY[HEADER] {105}
S: From: sender@example.com
S: To: user1@tio.com
S: Subject: Test Mail 1
S: 
S: )
S: A005 OK FETCH completed.

# 8. 客户端将第一封邮件标记为已读
C: A006 STORE 1 +FLAGS (\Seen)
S: * 1 FETCH (FLAGS (\Seen))
S: A006 OK STORE completed.

# 9. 客户端登出
C: A007 LOGOUT
S: * BYE tio-mail-wing IMAP server signing off.
S: A007 OK LOGOUT completed.

# 连接已由外部主机关闭。
```

---

## 实现IMAP服务

### **第一步：创建 `ImapPacket` 和 `ImapSessionContext`**

#### 1. `ImapPacket.java`

```java
// src/main/java/com/tio/mail/wing/packet/ImapPacket.java
package com.tio.mail.wing.packet;

import com.litongjava.aio.Packet;

@SuppressWarnings("serial")
public class ImapPacket extends Packet {
  private String line;

  public ImapPacket(String line) {
    this.line = line;
  }

  public String getLine() {
    return line;
  }
}
```

#### 2. `ImapSessionContext.java`

IMAP 的会话上下文非常关键，需要管理状态、选定的邮箱等信息。

```java
package com.tio.mail.wing.handler;

import com.litongjava.tio.core.ChannelContext;
import com.litongjava.tio.core.Tio;
import com.tio.mail.wing.packet.ImapPacket;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ImapSessionContext {

  public enum State {
    NON_AUTHENTICATED, AUTHENTICATED, SELECTED
  }

  private State state = State.NON_AUTHENTICATED;
  private String username;
  private String selectedMailbox;

  // Helper methods for sending responses
  public static void send(ChannelContext ctx, String message) {
    Tio.send(ctx, new ImapPacket(message + "\r\n"));
  }

  public static void sendTaggedOk(ChannelContext ctx, String tag, String command) {
    send(ctx, tag + " OK " + command + " completed");
  }

  public static void sendTaggedNo(ChannelContext ctx, String tag, String command, String message) {
    send(ctx, tag + " NO " + command + " failed: " + message);
  }

  public static void sendTaggedBad(ChannelContext ctx, String tag, String message) {
    send(ctx, tag + " BAD " + message);
  }

  public static void sendUntagged(ChannelContext ctx, String message) {
    send(ctx, "* " + message);
  }
}
```

### **第二步：修改模型和服务**

#### 1. `Email.java` (添加 `flags` 字段)

```java
// src/main/java/com/tio/mail/wing/model/Email.java
package com.tio.mail.wing.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

@Data
@NoArgsConstructor
public class Email {
  // ... (uid, size, content, deleted 字段保留)
  private String uid;
  private int size;
  private String content;
  private   deleted = false;

  /**
   * IMAP 标志 (e.g., \Seen, \Answered, \Flagged)
   */
  private Set<String> flags = new HashSet<>();

  public Email(String content) {
    this.content = content;
    this.size = content.getBytes().length;
    this.uid = UUID.randomUUID().toString().replace("-", "");
    // 新邮件默认是 \Recent
    this.flags.add("\\Recent");
  }
  
  // ... (原有 AllArgsConstructor 可以保留或删除)
}
```

#### 2. `MailboxService.java` (添加 IMAP 相关方法)

```java
// src/main/java/com/tio/mail/wing/service/MailboxService.java
package com.tio.mail.wing.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import com.tio.mail.wing.model.Email;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class MailboxService {

  /**
   * 模拟邮件存储系统
   * Key: 用户名 (e.g., "user1@tio.com")
   * Value: 该用户的邮件列表 (List<Email>)
   */
  private static final Map<String, List<Email>> mailboxes = new ConcurrentHashMap<>();

  // 使用静态代码块初始化一些模拟数据
  static {
    // 为 user1@tio.com 创建邮箱并添加两封邮件
    List<Email> user1Emails = new ArrayList<>();
    user1Emails.add(new Email("From: sender@example.com\r\n" + "To: user1@tio.com\r\n" + "Subject: Test Mail 1\r\n" + "\r\n" + "This is the body of the first email."));
    user1Emails.add(new Email("From: another@example.com\r\n" + "To: user1@tio.com\r\n" + "Subject: Hello World\r\n" + "\r\n" + "This is the second message."));
    mailboxes.put("user1@tio.com", user1Emails);

    // 为 user2@tio.com 创建一个空邮箱
    mailboxes.put("user2@tio.com", new ArrayList<>());
  }

  /**
   * 获取用户邮箱中所有未被标记为删除的邮件。
   * @param username 用户名
   * @return 邮件列表
   */
  public List<Email> getActiveMessages(String username) {
    List<Email> userEmails = mailboxes.getOrDefault(username, new ArrayList<>());
    return userEmails.stream().filter(email -> !email.isDeleted()).collect(Collectors.toList());
  }

  /**
   * 获取邮箱状态（邮件数，总大小）
   * @param username 用户名
   * @return int[]{邮件数, 总大小}
   */
  public int[] getStat(String username) {
    List<Email> activeMessages = getActiveMessages(username);
    int count = activeMessages.size();
    int totalSize = activeMessages.stream().mapToInt(Email::getSize).sum();
    return new int[] { count, totalSize };
  }

  /**
   * 获取邮件大小列表，用于 LIST 命令。
   * @param username 用户名
   * @return 邮件大小列表
   */
  public List<Integer> listMessages(String username) {
    return getActiveMessages(username).stream().map(Email::getSize).collect(Collectors.toList());
  }

  /**
   * 获取指定邮件内容
   * @param username 用户名
   * @param msgNumber 邮件序号 (从 1 开始)
   * @return 邮件原始内容
   */
  public String getMessageContent(String username, int msgNumber) {
    List<Email> activeMessages = getActiveMessages(username);
    // 序号从 1 开始，列表索引从 0 开始，需要转换
    if (msgNumber > 0 && msgNumber <= activeMessages.size()) {
      return activeMessages.get(msgNumber - 1).getContent();
    }
    return null;
  }

  // --- 新增方法以支持 UIDL ---
  /**
   * 获取邮件的唯一ID列表，用于 UIDL 命令。
   * @param username 用户名
   * @return 邮件的唯一ID列表
   */
  public List<String> listUids(String username) {
    return getActiveMessages(username).stream().map(Email::getUid).collect(Collectors.toList());
  }

  /**
   * 将接收到的邮件保存到指定用户的邮箱中
   * @param username 收件人用户名 (e.g., "user1@tio.com")
   * @param emailContent 邮件的完整原始内容 (MIME 格式)
   * @return 是否保存成功
   */
  public boolean saveEmail(String username, String emailContent) {
    List<Email> userEmails = mailboxes.computeIfAbsent(username, k -> new ArrayList<>());
    Email newEmail = new Email(emailContent);
    userEmails.add(newEmail);
    log.info("Saved new email for {} with UID {}", username, newEmail.getUid());
    return true;
  }

  /**
   * 检查用户是否存在（用于 RCPT TO 验证）
   * @param username 用户名
   * @return 是否存在
   */
  public boolean userExists(String username) {
    // 在真实系统中，这应该查询用户表
    // 这里我们用 UserService 的模拟数据来判断
    return mailboxes.containsKey(username);
  }

  /**
   * IMAP: 获取指定邮件 (按序号, 从1开始)
   * @param username 用户名
   * @param msgNumber 序号
   * @return Email对象或null
   */
  public Email getMessageByNumber(String username, int msgNumber) {
    List<Email> activeMessages = getActiveMessages(username);
    if (msgNumber > 0 && msgNumber <= activeMessages.size()) {
      return activeMessages.get(msgNumber - 1);
    }
    return null;
  }

  /**
   * IMAP: 修改邮件标志
   * @param username 用户名
   * @param msgNumber 序号
   * @param newFlags 新的标志集合
   * @param add true为添加, false为移除
   * @return 更新后的Email对象
   */
  public Email storeFlags(String username, int msgNumber, Set<String> newFlags, boolean add) {
    Email email = getMessageByNumber(username, msgNumber);
    if (email != null) {
      if (add) {
        email.getFlags().addAll(newFlags);
      } else {
        email.getFlags().removeAll(newFlags);
      }
      // \Recent 标志在被操作后通常会移除
      email.getFlags().remove("\\Recent");
    }
    return email;
  }

  /**
   * IMAP: 根据 UID 获取邮件
   * @param username 用户名
   * @param uid 唯一标识符
   * @return Email对象或null
   */
  public Email getMessageByUid(String username, String uid) {
    return getActiveMessages(username).stream().filter(email -> uid.equals(email.getUid())).findFirst().orElse(null);
  }
}
```

### **第三步：创建 IMAP 的 Listener 和 Handler**

#### 1. `ImapServerAioListener.java`

```java
// src/main/java/com/tio/mail/wing/listener/ImapServerAioListener.java
package com.tio.mail.wing.listener;

import com.litongjava.aio.Packet;
import com.litongjava.tio.core.ChannelContext;
import com.litongjava.tio.server.intf.ServerAioListener;
import com.tio.mail.wing.handler.ImapSessionContext;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ImapServerAioListener implements ServerAioListener {

  @Override
  public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) throws Exception {
    if (isConnected) {
      log.info("IMAP client connected: {}", channelContext.getClientNode());
      channelContext.set("sessionContext", new ImapSessionContext());
      // 发送欢迎消息
      ImapSessionContext.send(channelContext, "* OK tio-mail-wing IMAP4rev1 server ready");
    }
  }

  @Override
  public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) throws Exception {
    log.info("IMAP client disconnected: {}", channelContext.getClientNode());
  }

  @Override
  public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize) throws Exception {
    // TODO Auto-generated method stub

  }

  @Override
  public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes) throws Exception {
    // TODO Auto-generated method stub

  }

  @Override
  public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess) throws Exception {
    // TODO Auto-generated method stub

  }

  @Override
  public void onAfterHandled(ChannelContext channelContext, Packet packet, long cost) throws Exception {
    // TODO Auto-generated method stub

  }

  @Override
  public boolean onHeartbeatTimeout(ChannelContext channelContext, Long interval, int heartbeatTimeoutCount) {
    // TODO Auto-generated method stub
    return false;
  }

}
```

#### 2. `ImapServerAioHandler.java`

这是最复杂的部分，我们将实现 MVP 命令集。

```java
// src/main/java/com/tio/mail/wing/handler/ImapServerAioHandler.java
package com.tio.mail.wing.handler;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.litongjava.aio.Packet;
import com.litongjava.jfinal.aop.Aop;
import com.litongjava.tio.core.ChannelContext;
import com.litongjava.tio.core.Tio;
import com.litongjava.tio.core.TioConfig;
import com.litongjava.tio.core.exception.LengthOverflowException;
import com.litongjava.tio.core.exception.TioDecodeException;
import com.litongjava.tio.core.utils.ByteBufferUtils;
import com.litongjava.tio.server.intf.ServerAioHandler;
import com.litongjava.tio.utils.encoder.Base64Utils;
import com.tio.mail.wing.model.Email;
import com.tio.mail.wing.packet.ImapPacket;
import com.tio.mail.wing.service.MailboxService;
import com.tio.mail.wing.service.UserService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ImapServerAioHandler implements ServerAioHandler {

  private UserService userService = Aop.get(UserService.class);
  private MailboxService mailboxService = Aop.get(MailboxService.class);
  private static final String CHARSET = "UTF-8";

  @Override
  public Packet decode(ByteBuffer buffer, int limit, int position, int readableLength, ChannelContext ctx) throws TioDecodeException {
    String line = null;
    try {
      line = ByteBufferUtils.readLine(buffer, CHARSET);
    } catch (LengthOverflowException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return line == null ? null : new ImapPacket(line);
  }

  @Override
  public ByteBuffer encode(Packet packet, TioConfig tioConfig, ChannelContext ctx) {
    ImapPacket imapPacket = (ImapPacket) packet;
    try {
      return ByteBuffer.wrap(imapPacket.getLine().getBytes(CHARSET));
    } catch (Exception e) {
      log.error("Encoding error", e);
      return null;
    }
  }

  @Override
  public void handler(Packet packet, ChannelContext ctx) throws Exception {
    ImapPacket imapPacket = (ImapPacket) packet;
    String line = imapPacket.getLine().trim();
    log.info("IMAP <<< {}", line);

    ImapSessionContext session = (ImapSessionContext) ctx.get("sessionContext");

    if (session.getState() == ImapSessionContext.State.AUTH_WAIT_USERNAME || session.getState() == ImapSessionContext.State.AUTH_WAIT_PASSWORD) {
      handleAuthData(ctx, session, line);
      return;
    }

    String[] parts = line.split("\\s+", 3);
    String tag = parts[0];
    String command = parts.length > 1 ? parts[1].toUpperCase() : "";
    String args = parts.length > 2 ? parts[2] : "";

    try {
      switch (command) {
      case "CAPABILITY":
        handleCapability(ctx, tag);
        break;
      case "AUTHENTICATE":
        handleAuthenticate(ctx, session, tag, args);
        break;
      case "LOGIN":
        handleLogin(ctx, session, tag, args);
        break;
      case "LOGOUT":
        handleLogout(ctx, tag);
        break;
      case "LIST":
        handleList(ctx, tag, args, command);
        break;

      case "LSUB":
        handleList(ctx, tag, args, command);
        break;
      case "CREATE":
        handleCreate(ctx, tag, args);
        break;
      case "SUBSCRIBE":
        handleSubscribe(ctx, tag, args);
        break;
      case "SELECT":
        handleSelect(ctx, session, tag, args);
        break;
      case "FETCH":
        handleFetch(ctx, session, tag, args);
        break;
      case "STORE":
        handleStore(ctx, session, tag, args);
        break;
      case "UID":
        handleUid(ctx, session, tag, args);
        break;
      case "NOOP":
        ImapSessionContext.sendTaggedOk(ctx, tag, "NOOP");
        break;
      default:
        ImapSessionContext.sendTaggedBad(ctx, tag, "Unknown or unimplemented command");
      }
    } catch (Exception e) {
      log.error("Error handling IMAP command", e);
      ImapSessionContext.sendTaggedBad(ctx, tag, "Internal server error");
    }
  }

  private void handleSubscribe(ChannelContext ctx, String tag, String args) {
    // 假装订阅成功
    ImapSessionContext.sendTaggedOk(ctx, tag, "SUBSCRIBE");
  }

  private void handleCreate(ChannelContext ctx, String tag, String args) {
    // 假装创建成功
    ImapSessionContext.sendTaggedOk(ctx, tag, "CREATE");
  }

  private void handleCapability(ChannelContext ctx, String tag) {
    ImapSessionContext.sendUntagged(ctx, "CAPABILITY IMAP4rev1 AUTH=LOGIN");
    ImapSessionContext.sendTaggedOk(ctx, tag, "CAPABILITY");
  }

  private void handleAuthenticate(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    if (!"LOGIN".equalsIgnoreCase(args)) {
      ImapSessionContext.sendTaggedBad(ctx, tag, "Unsupported authentication mechanism");
      return;
    }

    // 1. 暂存命令的 tag，以便在认证流程结束后使用
    session.setCurrentCommandTag(tag);
    // 2. 更新会话状态
    session.setState(ImapSessionContext.State.AUTH_WAIT_USERNAME);
    // 3. 发送第一个挑战：Base64 编码的 "Username:"
    String challenge = Base64Utils.encodeToString("Username:".getBytes(StandardCharsets.UTF_8));
    ImapSessionContext.send(ctx, "+ " + challenge);
  }

  /**
   * 处理认证流程中的 Base64 数据（用户名和密码）
   */
  private void handleAuthData(ChannelContext ctx, ImapSessionContext session, String base64Data) {
    String tag = session.getCurrentCommandTag();
    try {
      String decodedData = Base64Utils.decodeToString(base64Data);

      if (session.getState() == ImapSessionContext.State.AUTH_WAIT_USERNAME) {
        // 收到的是用户名
        session.setUsername(decodedData);
        session.setState(ImapSessionContext.State.AUTH_WAIT_PASSWORD);
        // 发送密码挑战：Base64 编码的 "Password:"
        String challenge = Base64Utils.encodeToString("Password:".getBytes(StandardCharsets.UTF_8));
        ImapSessionContext.send(ctx, "+ " + challenge);

      } else if (session.getState() == ImapSessionContext.State.AUTH_WAIT_PASSWORD) {
        // 收到的是密码，进行最终认证
        String username = session.getUsername();
        String password = decodedData;

        if (userService.authenticate(username, password)) {
          // 认证成功
          session.setState(ImapSessionContext.State.AUTHENTICATED);
          ImapSessionContext.sendTaggedOk(ctx, tag, "AUTHENTICATE");
        } else {
          // 认证失败
          session.setState(ImapSessionContext.State.NON_AUTHENTICATED);
          ImapSessionContext.sendTaggedNo(ctx, tag, "AUTHENTICATE", "Authentication failed");
        }
        // 认证流程结束，清空暂存的 tag
        session.setCurrentCommandTag(null);
      }
    } catch (IllegalArgumentException e) {
      // Base64 解码失败
      session.setState(ImapSessionContext.State.NON_AUTHENTICATED);
      ImapSessionContext.sendTaggedBad(ctx, tag, "Invalid base64 data");
      session.setCurrentCommandTag(null);
    }
  }

  private void handleLogin(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    String[] parts = args.split("\\s+", 2);
    if (parts.length < 2) {
      ImapSessionContext.sendTaggedBad(ctx, tag, "LOGIN arguments invalid");
      return;
    }
    String username = unquote(parts[0]);
    String password = unquote(parts[1]);
    if (userService.authenticate(username, password)) {
      session.setUsername(username);
      session.setState(ImapSessionContext.State.AUTHENTICATED);
      ImapSessionContext.sendTaggedOk(ctx, tag, "LOGIN");
    } else {
      ImapSessionContext.sendTaggedNo(ctx, tag, "LOGIN", "Authentication failed");
    }
  }

  private void handleLogout(ChannelContext ctx, String tag) {
    ImapSessionContext.sendUntagged(ctx, "BYE tio-mail-wing IMAP server signing off");
    ImapSessionContext.sendTaggedOk(ctx, tag, "LOGOUT");
    if (!ctx.isClosed) {
      Tio.close(ctx, "LOGOUT");
    }

  }

  private void handleList(ChannelContext ctx, String tag, String args, String command) {
    // 简化实现，忽略参数，只返回 INBOX
    ImapSessionContext.sendUntagged(ctx, "LIST (\\HasNoChildren) \"/\" INBOX");
    ImapSessionContext.sendTaggedOk(ctx, tag, command.toUpperCase()); // 使用 command 变量
  }

  private void handleSelect(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    String mailbox = unquote(args);
    if (!"INBOX".equalsIgnoreCase(mailbox)) {
      ImapSessionContext.sendTaggedNo(ctx, tag, "SELECT", "Mailbox not found: " + mailbox);
      return;
    }
    session.setSelectedMailbox(mailbox);
    session.setState(ImapSessionContext.State.SELECTED);
    int[] stats = mailboxService.getStat(session.getUsername());
    long recentCount = mailboxService.getActiveMessages(session.getUsername()).stream().filter(e -> e.getFlags().contains("\\Recent")).count();
    ImapSessionContext.sendUntagged(ctx, "FLAGS (\\Answered \\Flagged \\Deleted \\Seen \\Draft)");
    ImapSessionContext.sendUntagged(ctx, stats[0] + " EXISTS");
    ImapSessionContext.sendUntagged(ctx, recentCount + " RECENT");
    ImapSessionContext.sendUntagged(ctx, "OK [UNSEEN 1] First unseen message is 1.");
    ImapSessionContext.sendUntagged(ctx, "OK [UIDVALIDITY " + System.currentTimeMillis() / 1000 + "] UIDs valid.");
    ImapSessionContext.sendTaggedOk(ctx, tag, "[READ-WRITE] SELECT");
  }

  private void handleFetch(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    if (session.getState() != ImapSessionContext.State.SELECTED) {
      ImapSessionContext.sendTaggedNo(ctx, tag, "FETCH", "No mailbox selected");
      return;
    }
    String[] parts = args.split("\\s+", 2);
    int msgNumber = Integer.parseInt(parts[0]);
    String fetchItems = parts[1];
    Email email = mailboxService.getMessageByNumber(session.getUsername(), msgNumber);
    if (email == null) {
      ImapSessionContext.sendTaggedNo(ctx, tag, "FETCH", "No such message");
      return;
    }
    if (fetchItems.toUpperCase().contains("BODY[]") || fetchItems.toUpperCase().contains("BODY.PEEK[]")) {
      String content = email.getContent();
      ImapSessionContext.sendUntagged(ctx, msgNumber + " FETCH (BODY[] {" + content.getBytes().length + "}");
      ImapSessionContext.send(ctx, content + ")");
    } else if (fetchItems.toUpperCase().contains("FLAGS")) {
      String flagsStr = String.join(" ", email.getFlags());
      ImapSessionContext.sendUntagged(ctx, msgNumber + " FETCH (FLAGS (" + flagsStr + "))");
    } else {
      ImapSessionContext.sendUntagged(ctx, msgNumber + " FETCH ()");
    }
    ImapSessionContext.sendTaggedOk(ctx, tag, "FETCH");
  }

  private void handleStore(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    if (session.getState() != ImapSessionContext.State.SELECTED) {
      ImapSessionContext.sendTaggedNo(ctx, tag, "STORE", "No mailbox selected");
      return;
    }
    String[] parts = args.split("\\s+", 3);
    int msgNumber = Integer.parseInt(parts[0]);
    String operation = parts[1].toUpperCase();
    String flagsStr = parts[2].replaceAll("[()]", "");
    Set<String> flags = new HashSet<>(Arrays.asList(flagsStr.split("\\s+")));
    boolean add = operation.equals("+FLAGS") || operation.equals("+FLAGS.SILENT");
    Email updatedEmail = mailboxService.storeFlags(session.getUsername(), msgNumber, flags, add);
    if (updatedEmail != null && !operation.contains(".SILENT")) {
      String updatedFlagsStr = String.join(" ", updatedEmail.getFlags());
      ImapSessionContext.sendUntagged(ctx, msgNumber + " FETCH (FLAGS (" + updatedFlagsStr + "))");
    }
    ImapSessionContext.sendTaggedOk(ctx, tag, "STORE");
  }

  private void handleUid(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    if (session.getState() != ImapSessionContext.State.SELECTED) {
      ImapSessionContext.sendTaggedNo(ctx, tag, "UID", "No mailbox selected");
      return;
    }

    String[] parts = args.split("\\s+", 2);
    String subCommand = parts[0].toUpperCase();
    String subArgs = parts.length > 1 ? parts[1] : "";

    if ("FETCH".equals(subCommand)) {
      handleUidFetch(ctx, session, tag, subArgs);
    } else {
      ImapSessionContext.sendTaggedBad(ctx, tag, "Unsupported UID command: " + subCommand);
    }
  }

  private void handleUidFetch(ChannelContext ctx, ImapSessionContext session, String tag, String args) {
    // 正则表达式现在需要更灵活，以匹配可选的 BODY 部分
    // 示例: 1:* (FLAGS)  或  995 (UID ... BODY.PEEK[...])
    java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("([\\d\\*:,]+)\\s+\\((.*)\\)", java.util.regex.Pattern.CASE_INSENSITIVE);
    java.util.regex.Matcher matcher = pattern.matcher(args);

    if (!matcher.find()) {
      ImapSessionContext.sendTaggedBad(ctx, tag, "Invalid UID FETCH arguments: " + args);
      return;
    }

    String messageSet = matcher.group(1);
    String fetchItemsStr = matcher.group(2);

    java.util.List<com.tio.mail.wing.model.Email> emailsToFetch = new java.util.ArrayList<>();
    if (messageSet.equals("1:*")) {
      emailsToFetch.addAll(mailboxService.getActiveMessages(session.getUsername()));
    } else {
      // 假设是单个UID或逗号分隔的UID列表
      for (String uid : messageSet.split(",")) {
        com.tio.mail.wing.model.Email email = mailboxService.getMessageByUid(session.getUsername(), uid);
        if (email != null) {
          emailsToFetch.add(email);
        }
      }
    }

    if (emailsToFetch.isEmpty()) {
      ImapSessionContext.sendTaggedOk(ctx, tag, "UID FETCH");
      return;
    }

    for (com.tio.mail.wing.model.Email email : emailsToFetch) {
      // 获取邮件在当前活跃列表中的序号
      int sequenceNumber = mailboxService.getActiveMessages(session.getUsername()).indexOf(email) + 1;
      if (sequenceNumber == 0)
        continue; // 如果邮件已被删除或不在活跃列表中，则跳过

      StringBuilder responsePrefix = new StringBuilder();
      responsePrefix.append(String.format("* %d FETCH (", sequenceNumber));

      String headerContent = null;
      String bodyPartName = null;

      // =================================================================
      // 关键修复：无条件添加 UID，这是协议强制要求的
      // =================================================================
      responsePrefix.append("UID ").append(email.getUid()).append(" ");

      // --- 逐项解析客户端请求的数据项 ---
      if (fetchItemsStr.toUpperCase().contains("FLAGS")) {
        responsePrefix.append("FLAGS (").append(String.join(" ", email.getFlags())).append(") ");
      }
      if (fetchItemsStr.toUpperCase().contains("RFC822.SIZE")) {
        responsePrefix.append("RFC822.SIZE ").append(email.getSize()).append(" ");
      }

      // --- 分离处理 BODY.PEEK，因为它需要特殊的字面量响应格式 ---
      java.util.regex.Pattern bodyPattern = java.util.regex.Pattern.compile("(BODY\\.PEEK\\[HEADER\\.FIELDS \\(.*?\\)\\])", java.util.regex.Pattern.CASE_INSENSITIVE);
      java.util.regex.Matcher bodyMatcher = bodyPattern.matcher(fetchItemsStr);
      if (bodyMatcher.find()) {
        bodyPartName = bodyMatcher.group(1);
        // 从邮件内容中解析出请求的头部字段
        // 为了简化，我们仍然返回固定的几个字段，但使用客户端请求的 part name
        headerContent = parseHeaderFields(email.getContent(), new String[] { "From", "To", "Subject", "Date" });
        responsePrefix.append(bodyPartName).append(" {").append(headerContent.getBytes(java.nio.charset.StandardCharsets.UTF_8).length).append("}");
      }

      // 移除末尾可能多余的空格
      if (responsePrefix.charAt(responsePrefix.length() - 1) == ' ') {
        responsePrefix.setLength(responsePrefix.length() - 1);
      }

      // --- 构建并发送最终响应 ---
      if (headerContent != null) {
        // 对于有 BODY 内容的响应，需要分多步发送
        // 1. 发送包含 {size} 的前缀和结束括号
        ImapSessionContext.send(ctx, responsePrefix.toString());
        // 2. 发送 BODY 内容本身
        ImapSessionContext.send(ctx, headerContent);
        ImapSessionContext.send(ctx, ")");
      } else {
        // 对于没有 BODY 内容的响应，一次性发送
        responsePrefix.append(")");
        ImapSessionContext.send(ctx, responsePrefix.toString());
      }
    }

    ImapSessionContext.sendTaggedOk(ctx, tag, "UID FETCH");
  }

  /**
   * 从邮件原始内容中解析指定的头部字段
   */
  private String parseHeaderFields(String mailContent, String[] requestedFields) {
    Map<String, String> headers = new HashMap<>();
    String[] lines = mailContent.split("\r\n");
    for (String line : lines) {
      if (line.isEmpty()) {
        break; // 邮件头结束
      }
      int colonIndex = line.indexOf(':');
      if (colonIndex > 0) {
        String key = line.substring(0, colonIndex).trim();
        String value = line.substring(colonIndex + 1).trim();
        headers.put(key.toUpperCase(), value);
      }
    }

    StringBuilder result = new StringBuilder();
    for (String field : requestedFields) {
      String value = headers.get(field.toUpperCase());
      if (value != null) {
        result.append(field).append(": ").append(value).append("\r\n");
      }
    }
    return result.toString();
  }

  private String unquote(String s) {
    if (s != null && s.startsWith("\"") && s.endsWith("\"")) {
      return s.substring(1, s.length() - 1);
    }
    return s;
  }

}
```

### **第四步：创建 IMAP 服务器配置**

#### `ImapServerConfig.java`

```java
// src/main/java/com/tio/mail/wing/config/ImapServerConfig.java
package com.tio.mail.wing.config;

import com.litongjava.annotation.AConfiguration;
import com.litongjava.annotation.Initialization;
import com.litongjava.tio.server.ServerTioConfig;
import com.litongjava.tio.server.TioServer;
import com.litongjava.tio.utils.environment.EnvUtils;
import com.tio.mail.wing.handler.ImapServerAioHandler;
import com.tio.mail.wing.listener.ImapServerAioListener;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

@AConfiguration
@Slf4j
public class ImapServerConfig {

  @Initialization
  public void startImapServer() {
    ImapServerAioHandler serverHandler = new ImapServerAioHandler();
    ImapServerAioListener serverListener = new ImapServerAioListener();

    ServerTioConfig serverTioConfig = new ServerTioConfig("imap-server");
    serverTioConfig.setServerAioHandler(serverHandler);
    serverTioConfig.setServerAioListener(serverListener);
    serverTioConfig.setHeartbeatTimeout(-1);
    serverTioConfig.checkAttacks = false;

    TioServer tioServer = new TioServer(serverTioConfig);

    try {
      int port = EnvUtils.getInt("mail.server.imap.port", 143);
      tioServer.start(null, port);
      log.info("Started IMAP server on port: {}", port);
    } catch (IOException e) {
      log.error("Failed to start IMAP server", e);
    }
  }
}
```

---

## 测试

IMAP 的测试比前两者更依赖于标准的邮件客户端，因为手动 `telnet` 交互非常繁琐。

### 1. 使用 `telnet` 手动测试 (用于调试)

你可以按照上面 "一个完整的 Telnet 交互示例" 中的步骤，手动输入命令来验证服务器的基本响应是否正确。这是调试 `SELECT`、`FETCH` 等复杂命令响应格式的最佳方式。
### 2.使用curl进行测试

列出邮箱中的邮件
```curl
curl -v --url "imap://localhost:143/INBOX" --user "user1@tio.com:pass1"
```

```
* Host localhost:143 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
*   Trying [::1]:143...
* Connected to localhost (::1) port 143
< * OK tio-mail-wing IMAP4rev1 server ready
> A001 CAPABILITY
< * CAPABILITY IMAP4rev1 AUTH=LOGIN
< A001 OK CAPABILITY completed
> A002 AUTHENTICATE LOGIN
< + VXNlcm5hbWU6
> dXNlcjFAdGlvLmNvbQ==
< + UGFzc3dvcmQ6
> cGFzczE=
< A002 OK AUTHENTICATE completed
> A003 LIST "INBOX" *
< * LIST (\HasNoChildren) "/" INBOX
* LIST (\HasNoChildren) "/" INBOX
< A003 OK LIST completed
* Connection #0 to host localhost left intact

```

测试场景：获取特定邮件的内容
```curl
curl -v --url "imap://localhost:143/INBOX/1" --user "user1@tio.com:pass1"
```

```
* Host localhost:143 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
*   Trying [::1]:143...
* Connected to localhost (::1) port 143
< * OK tio-mail-wing IMAP4rev1 server ready
> A001 CAPABILITY
< * CAPABILITY IMAP4rev1 AUTH=LOGIN
< A001 OK CAPABILITY completed
> A002 AUTHENTICATE LOGIN
< + VXNlcm5hbWU6
> dXNlcjFAdGlvLmNvbQ==
< + UGFzc3dvcmQ6
> cGFzczE=
< A002 OK AUTHENTICATE completed
> A003 LIST "INBOX/1" *
< * LIST (\HasNoChildren) "/" INBOX
* LIST (\HasNoChildren) "/" INBOX
< A003 OK LIST completed
* Connection #0 to host localhost left intact
```

查看INBOX下面的所有邮件
```curl
curl -v --url "imap://localhost:143/" --user "user1@tio.com:pass1" -X "SELECT INBOX"
```

```
* Host localhost:143 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
*   Trying [::1]:143...
* Connected to localhost (::1) port 143
< * OK tio-mail-wing IMAP4rev1 server ready
> A001 CAPABILITY
< * CAPABILITY IMAP4rev1 AUTH=LOGIN
< A001 OK CAPABILITY completed
> A002 AUTHENTICATE LOGIN
< + VXNlcm5hbWU6
> dXNlcjFAdGlvLmNvbQ==
< + UGFzc3dvcmQ6
> cGFzczE=
< A002 OK AUTHENTICATE completed
> A003 SELECT INBOX
< * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
* FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
< * 2 EXISTS
* 2 EXISTS
< * 2 RECENT
* 2 RECENT
< * OK [UNSEEN 1] First unseen message is 1.
* OK [UNSEEN 1] First unseen message is 1.
< * OK [UIDVALIDITY 1750650740] UIDs valid.
* OK [UIDVALIDITY 1750650740] UIDs valid.
< A003 OK [READ-WRITE] SELECT completed
* Connection #0 to host localhost left intact
```
4. 读取文件内容
```curl
curl -v --url "imap://localhost:143/INBOX" --user "user1@tio.com:pass1" -X "FETCH 1 BODY[]"
```

```
* Host localhost:143 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
*   Trying [::1]:143...
* Connected to localhost (::1) port 143
< * OK tio-mail-wing IMAP4rev1 server ready
> A001 CAPABILITY
< * CAPABILITY IMAP4rev1 AUTH=LOGIN
< A001 OK CAPABILITY completed
> A002 AUTHENTICATE LOGIN
< + VXNlcm5hbWU6
> dXNlcjFAdGlvLmNvbQ==
< + UGFzc3dvcmQ6
> cGFzczE=
< A002 OK AUTHENTICATE completed
> A003 SELECT INBOX
< * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
< * 2 EXISTS
< * 2 RECENT
< * OK [UNSEEN 1] First unseen message is 1.
< * OK [UIDVALIDITY 1750650951] UIDs valid.
< A003 OK [READ-WRITE] SELECT completed
> A004 FETCH 1 BODY[]
< * 1 FETCH (BODY[] {105}
* 1 FETCH (BODY[] {105}
< From: sender@example.com
< To: user1@tio.com
< Subject: Test Mail 1
<
< This is the body of the first email.)
< A004 OK FETCH completed
* Connection #0 to host localhost left intact
```

5. 执行自定义 IMAP 命令
curl 最强大的功能是允许你通过 -X 或 --request 参数发送任意的 IMAP 命令。这让你摆脱了 URL 格式的限制。
```
# 执行 "STATUS INBOX (MESSAGES UNSEEN)" 命令
curl -v --url "imap://localhost:143/" --user "user1@tio.com:pass1" -X "STATUS INBOX (MESSAGES UNSEEN)"
```
### 3. 使用邮件客户端 (Thunderbird/Foxmail/Apple Mail)

这是验证 IMAP 服务是否可用的最终方法。

1.  在你的邮件客户端中，**添加一个新账户**。
2.  选择手动配置，服务器类型选择 **IMAP**。
3.  **接收邮件服务器 (IMAP)**:
    *   服务器地址: `localhost`
    *   端口: `143`
    *   用户名: `user1@tio.com`
    *   密码: `pass1`
    *   加密: 无 (或 `None`)
    *   认证方式: `普通密码` 或 `Password, normal`
4.  **发送邮件服务器 (SMTP)**: (使用我们之前已完成的 SMTP 配置)
    *   服务器地址: `localhost`
    *   端口: `25`
    *   用户名: `user2@tio.com`
    *   密码: `pass2`
    *   加密: 无
    *   认证方式: `普通密码`
5.  完成配置。客户端应该能够：
    *   成功连接并同步 `INBOX` 文件夹。
    *   在邮件列表中显示 `user1@tio.com` 邮箱中的邮件（包括主题、发件人等）。
    *   点击一封邮件时，能够加载并显示其完整内容。
    *   当你阅读一封邮件后，客户端会发送 `STORE ... +FLAGS (\Seen)` 命令，邮件应变为已读状态。
    *   尝试发送一封邮件，它应该能通过我们的 SMTP 服务发出，并被 POP3/IMAP 服务接收到。

如果以上步骤都能成功，那么恭喜你！你已经成功搭建了一个支持 POP3、SMTP 和 IMAP 协议的基础邮件服务器！万里长征已经迈出了最关键的几步。接下来的工作将是完善细节、加强安全（STARTTLS/SSL）和优化存储。