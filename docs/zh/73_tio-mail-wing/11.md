# IMAP实现讲解


## 邮件格式内容示例
```
Message-ID: <ad5355e1-7be5-4fdb-aacc-1b992a67180b@tio.com>
Date: Wed, 25 Jun 2025 23:45:07 -1000
MIME-Version: 1.0
User-Agent: default/1.0
Content-Type: text/plain; charset=UTF-8
From: user1@tio.com
To: user2@tio.com
Subject: hi

hi
```
##

## 查询邮件SQL
### SQL
```sql
SELECT
  ranked.id,
  ranked.uid,
  ranked.internal_date,
  msg.raw_content,
  msg.size_in_bytes,
  ranked.seq_num,
  COALESCE(
    ARRAY_AGG(mf.flag) FILTER (WHERE mf.flag IS NOT NULL),
    '{}'
  ) AS flags
FROM (
  -- 子查询：给每条未删除的邮件按 uid 升序打上临时序号 seq_num
  SELECT
    m.id,
    m.uid,
    m.internal_date,
    m.message_id,
    ROW_NUMBER() OVER (ORDER BY m.uid ASC) AS seq_num
  FROM mw_mail m
  WHERE m.mailbox_id = 100201
    AND NOT EXISTS (
      SELECT 1
      FROM mw_mail_flag del_mf
      WHERE del_mf.mail_id = m.id
        AND del_mf.flag = '\Deleted'
    )
) AS ranked
JOIN mw_mail_message msg
  ON ranked.message_id = msg.id
LEFT JOIN mw_mail_flag mf
  ON ranked.id = mf.mail_id
GROUP BY
  ranked.id,
  ranked.uid,
  ranked.internal_date,
  msg.raw_content,
  msg.size_in_bytes,
  ranked.seq_num
ORDER BY
  ranked.uid ASC;
```

* **子查询 `ranked`**

  * 针对指定 `mailbox_id`（100201）下的所有邮件，排除掉带有 `\Deleted` 标志的条目。
  * 使用 `ROW_NUMBER() OVER (ORDER BY m.uid ASC)` 为每封“未删除”邮件按 `uid` 从小到大计算一个**临时序号** `seq_num`。

* **主查询**

  * 将打好号的结果 (`ranked`) 与 `mw_mail_message` 表（存放邮件正文、大小等）关联，得到 `raw_content` 和 `size_in_bytes`。
  * 再左连接 `mw_mail_flag`，把同一封邮件可能有的多条 flag 聚合成一个数组 `flags`（空时返回 `{}`）。
  * 最后 `GROUP BY` 所有非聚合字段，并按 `uid` 升序输出。

---

### 返回的单行数据解析

| 列名              | 值                                            | 含义                                                |
| --------------- | -------------------------------------------- | ------------------------------------------------- |
| `id`            | `527874583000649728`                         | 数据库主键，唯一标识这一封邮件（内部用）                              |
| `uid`           | `1`                                          | IMAP 中的 **唯一标识符**（UID），在同一个邮箱内从 1 开始递增            |
| `internal_date` | `2025-06-26 17:45:08.037+08`                 | 服务器接收这封邮件的时间（含时区）                                 |
| `raw_content`   | 邮件的完整原始文本，包括头部（Message-ID、Date、Subject……）和正文 | 存库时的 MIME 原始内容                                    |
| `size_in_bytes` | `241`                                        | 邮件正文体大小（字节）                                       |
| `seq_num`       | `1`                                          | **临时序号**：在当前查询结果里，这封邮件是第 1 封                      |
| `flags`         | `{"\\Recent"}`                               | 聚合后的标志数组，本例中仅有 `\Recent`，其它如 `\Seen`、`\Flagged` 等 |

* **`seq_num = 1`**：说明这是在这个邮箱里按 `uid` 升序的“第一封”非删除邮件。
* **`uid = 1`**：这是该邮箱真正持久化存储的 UID，新进来的邮件会递增，例如下封就是 UID 2。

---

## IMAP中的 message-id,uid,和seq_num
1. **Message-ID**

   * 它是邮件头（Header）中的一项字段，用来对每一封邮件进行全局唯一标识。典型格式类似：

     ```
     Message-ID: <随机串@域名>
     ```
   * 由发信客户端或邮件服务器在发出邮件时生成，不同系统生成算法可能不同，但原则上在全互联网范围内不重复，用于引用、去重和讨论线程的关联。

2. **`UID FETCH 1:* (FLAGS)` 中的 `1:*`**

   * 因为命令以 `UID` 开头，所以这里的数字指的是 **UID**，不是序列号（seq_num）。
   * 如果你写的是普通的 `FETCH 1:* (FLAGS)`（无 UID 前缀），那 `1:*` 就代表序列号范围；加上 `UID` 后，就是用 UID 号去 FETCH。

3. **UID 在同一用户同一邮箱下的唯一性**

   * IMAP 协议要求：每个 mailbox（信箱）内部的 UID 必须唯一，且由服务器分配，通常是严格递增且永不重用的整数。
   * 也就是说，同一个用户的同一个 mailbox 下，不会存在两个相同的 UID；即使某封邮件被删除（EXPUNGE），服务器也不应再给新邮件分配相同的 UID。

## 能否用 `uid` 代替 `seq_num`

* **IMAP 规范中两者语义不同**

  * **`uid`**（唯一标识符）是持久的 ：一旦分配给某封邮件，就不会改变，客户端可用它做幂等操作和“标记存取”。
  * **`seq_num`**（序列号）是临时的 ：它表示“当前邮箱里第 N 封邮件”，随着邮件的增加、删除、排序都会重新编号。

* **实践建议**

  * 如果你只关心“这个邮件在列表中的位置”，就取 `seq_num`；
  * 如果希望客户端能跨会话、跨排序地精准定位同一封邮件，就用 `uid`。

* **直接替换的后果**

  * 用 `uid` 当做 `seq_num` 的话：

    * 当有新邮件插入或旧邮件删除时，“第 5 封邮件”在新列表里的 `uid` 可能变成了 6、4、7……客户端的 FETCH、STORE 等命令就会错位。
  * 因此**不能**简单把 `uid` 当成 `seq_num` 返回，必须分别维护两者。

---

**总结**：

* `seq_num` 是为了 IMAP 客户端的临时定位而生，应该在每次 LIST/FETCH 时重新计算；
* `uid` 是邮件的长期 ID，用于标志存取；
* 两者各司其职，不能互换。

在 IMAP 协议中，即便客户端全部使用 `UID FETCH …` 命令，服务器在回复 FETCH 时依然必须在行首给出一个 **序列号（sequence number）**，后面才是实际的 `(UID 123 FLAGS (…)…)`。例如：

```
C: 44 UID FETCH 1:* (FLAGS)
S: * 1 FETCH (UID 1 FLAGS (\Seen))
```

– 这里的第一个 `1` 就是 sequence number（表示“当前邮箱的第 1 封消息”），紧跟其后的是 `UID 1`（表示这条消息的持久标识符）。

客户端之所以倾向于用 UID，是因为 UID 在整个会话乃至多次会话中都不会变，而 sequence number 会随着邮件的增加、删除和 EXPUNGE 操作而重新编号。但协议规范要求：

1. **所有 FETCH 响应行**（无论是普通 FETCH 还是 UID FETCH）都要以 sequence number 开头。
2. **UID FETCH** 在响应体里额外告诉客户端消息的 UID，但并不替代掉序列号。

因此：

* 如果你希望完全兼容 IMAP 客户端，就 **必须** 在你的 SQL 查询里计算并返回 `seq_num`（临时序号），从而在发送 FETCH 响应时把它填到 `* <seq_num> FETCH …` 的位置。
* 客户端确实会忽略或不主动用那第一个数字，但它**还是会被发送**，也是协议一部分。

总结：

* **不能**省略 `seq_num`，它是 FETCH 响应行首必需的；
* 客户端在解析时会同时看到序号和 UID，通常用 UID 进行后续操作，但规范上 sequence number 始终存在。

