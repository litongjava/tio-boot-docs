# 02

## topic

```
ç”¨å›¾å½¢åŒ–æ–¹å¼è¯æ˜Ž7x5x2=7x(5x2)
```

## åœºæ™¯æç¤º

```
## å›¾å½¢åŒ–è¯æ˜Žï¼šä¹˜æ³•ç»“åˆå¾‹ \( 7 \times 5 \times 2 = 7 \times (5 \times 2) \)

### ã€åœºæ™¯ä¸€ï¼šé—®é¢˜å¼•å…¥ä¸Žæ ‡é¢˜å±•ç¤ºã€‘

*   **èƒŒæ™¯è®¾è®¡ä¸Žæ•´ä½“æ°›å›´**
    *   èƒŒæ™¯é‡‡ç”¨ä»Žæµ…ç° (#DDDDDD) åˆ°ç™½è‰² (#FFFFFF) çš„åž‚ç›´æ¸å˜ï¼Œè¥é€ ç®€æ´ã€æ¸…æ™°çš„å­¦æœ¯æ°›å›´ã€‚
    *   å³ä¸Šè§’æ˜¾ç¤ºåœºæ™¯ç¼–å·â€œ01â€ï¼Œå­—ä½“ç¨å°ï¼Œé¢œè‰²ä¸ºæ·±ç°è‰² (#555555)ã€‚

*   **ä¸»è¦å†…å®¹**
    *   å±å¹•ä¸­å¿ƒåä¸Šä½ç½®å‡ºçŽ°æ ‡é¢˜ï¼šâ€œå›¾å½¢åŒ–è¯æ˜Žï¼šä¹˜æ³•ç»“åˆå¾‹â€ï¼Œæ–‡å­—é¢œè‰²ä¸ºé»‘è‰² (#000000)ï¼Œä½¿ç”¨ `Write` åŠ¨ç”»æ•ˆæžœï¼Œæ—¶é•¿ 1.5 ç§’ã€‚
    *   æ ‡é¢˜ä¸‹æ–¹å±•ç¤ºæ ¸å¿ƒå¾…è¯æ˜Žçš„æ•°å­¦å…¬å¼ï¼š
        \[
        7 \times 5 \times 2 = 7 \times (5 \times 2)
        \]
    *   è¯¥å…¬å¼ä½¿ç”¨ LaTeX æ¸²æŸ“ï¼Œå­—ä½“å¤§å°æ¯”æ ‡é¢˜ç¨å°ï¼Œé¢œè‰²ä¸ºæ·±è“ (#00008B)ã€‚é‡‡ç”¨ `FadeIn` åŠ¨ç”»æ•ˆæžœï¼Œåœ¨æ ‡é¢˜å®Œå…¨æ˜¾ç¤ºåŽå»¶è¿Ÿ 0.5 ç§’å‡ºçŽ°ï¼Œæ—¶é•¿ 1 ç§’ã€‚
    *   æ•°å­— 7ã€5ã€2 å¯ä»¥ä½¿ç”¨ä¸åŒé¢œè‰²ï¼ˆä¾‹å¦‚ï¼š7-çº¢è‰² #FF0000, 5-ç»¿è‰² #008000, 2-è“è‰² #0000FFï¼‰æ¥çªå‡ºå®ƒä»¬åœ¨åŽç»­å›¾å½¢åŒ–è¿‡ç¨‹ä¸­çš„å¯¹åº”å…³ç³»ï¼Œæ‹¬å·ä¹Ÿéœ€æ¸…æ™°æ˜¾ç¤ºã€‚

*   **ç›¸æœºä¸Žè¿‡æ¸¡æ•ˆæžœ**
    *   ç›¸æœºä¿æŒé™æ€ï¼Œèšç„¦äºŽå±å¹•ä¸­å¿ƒå†…å®¹ã€‚
    *   æ•´ä½“åŠ¨ç”»èŠ‚å¥æ¸…æ™°ï¼Œæ ‡é¢˜å’Œå…¬å¼ä¾æ¬¡å‡ºçŽ°ï¼Œç•™æœ‰è¶³å¤Ÿçš„é˜…è¯»æ—¶é—´ã€‚

---

### ã€åœºæ™¯äºŒï¼šå¯è§†åŒ–è®¡ç®— (7 x 5) x 2ã€‘

*   **èƒŒæ™¯ä¸Žå¸ƒå±€**
    *   èƒŒæ™¯ä¿æŒæµ…ç°åˆ°ç™½è‰²çš„æ¸å˜ã€‚
    *   å±å¹•å¸ƒå±€åˆ†ä¸ºå·¦å³ä¸¤éƒ¨åˆ†ï¼š
        *   å·¦ä¾§åŒºåŸŸï¼ˆçº¦å å±å¹• 1/3ï¼‰ç”¨äºŽæ˜¾ç¤ºæ–‡å­—è¯´æ˜Žå’Œè®¡ç®—æ­¥éª¤ã€‚
        *   å³ä¾§åŒºåŸŸï¼ˆçº¦å å±å¹• 2/3ï¼‰ç”¨äºŽå±•ç¤ºä¸‰ç»´å›¾å½¢å¯è§†åŒ–ã€‚
    *   å³ä¸Šè§’æ˜¾ç¤ºåœºæ™¯ç¼–å·â€œ02â€ã€‚
    *   åœ¨å³ä¾§åŒºåŸŸè®¾ç½®ä¸‰ç»´åæ ‡ç³» `ThreeDAxes`ï¼Œx, y, z è½´æœ‰æ¸…æ™°æ ‡ç­¾ï¼Œè½´èŒƒå›´å¤§è‡´ä¸º x: [0, 8], y: [0, 6], z: [0, 3]ã€‚

*   **å†…å®¹å‘ˆçŽ°**
    *   **å·¦ä¾§æ–‡æœ¬ä¸Žå…¬å¼ï¼š**
        1.  é¦–å…ˆå‡ºçŽ°æ–‡æœ¬ï¼šâ€œè®¡ç®—æ–¹å¼ä¸€ï¼šå…ˆç®— \(7 \times 5\)â€ï¼Œä½¿ç”¨ `Write` æ•ˆæžœï¼Œæ—¶é•¿ 1 ç§’ã€‚
        2.  ä¸‹æ–¹å±•ç¤ºè®¡ç®—è¿‡ç¨‹ï¼š
            \[
            (7 \times 5) \times 2
            \]
            è¯¥å…¬å¼ä½¿ç”¨ LaTeX æ¸²æŸ“ï¼Œå…¶ä¸­ `(7 \times 5)` éƒ¨åˆ†é«˜äº®ï¼ˆä¾‹å¦‚ï¼ŒèƒŒæ™¯è‰²è®¾ä¸ºæ·¡é»„è‰² #FFFFE0ï¼‰ã€‚`FadeIn` æ•ˆæžœï¼Œæ—¶é•¿ 0.5 ç§’ã€‚
        3.  å†ä¸‹æ–¹æ˜¾ç¤ºä¸­é—´ç»“æžœï¼šâ€œ\( 7 \times 5 = 35 \)â€ ï¼Œä½¿ç”¨ `Write` æ•ˆæžœï¼Œæ—¶é•¿ 1 ç§’ã€‚
        4.  æœ€åŽæ˜¾ç¤ºå®Œæ•´è®¡ç®—ï¼šâ€œ\( = 35 \times 2 = 70 \)â€ ï¼Œä½¿ç”¨ `ReplacementTransform` ä»Ž `(7 \times 5) \times 2` å¹³æ»‘è¿‡æ¸¡ï¼Œæ—¶é•¿ 1.5 ç§’ã€‚
    *   **å³ä¾§ä¸‰ç»´å¯è§†åŒ–ï¼š**
        1.  **æž„å»º 7x5 åº•é¢**ï¼šåœ¨ XY å¹³é¢ä¸Šï¼Œç”Ÿæˆä¸€ä¸ªç”± 7x5=35 ä¸ªå°ç«‹æ–¹ä½“ (`Cube`) ç»„æˆçš„ VGroupï¼ŒæŽ’åˆ—æˆ 7 è¡Œ 5 åˆ—ã€‚æ¯ä¸ªå°ç«‹æ–¹ä½“è¾¹é•¿ä¸º 0.5ã€‚ä½¿ç”¨ `Create` åŠ¨ç”»é€ä¸ªæˆ–é€è¡Œ/åˆ—ç”Ÿæˆï¼Œæ•´ä½“æ—¶é•¿ 2 ç§’ã€‚è¿™ç»„ç«‹æ–¹ä½“é¢œè‰²è®¾ä¸ºçº¢è‰² (#FF0000)ï¼Œä»£è¡¨æ•°å­— 7 çš„ç»´åº¦ï¼Œå’Œç»¿è‰² (#008000)ï¼Œä»£è¡¨æ•°å­— 5 çš„ç»´åº¦ï¼Œå¯ä»¥äº¤é”™æˆ–ç”¨è¾¹æ¡†é¢œè‰²åŒºåˆ†ã€‚æˆ–è€…ç»Ÿä¸€ç”¨ä¸€ç§é¢œè‰²ï¼ˆå¦‚æ©™è‰² #FFA500ï¼‰è¡¨ç¤ºä¹˜ç§¯ 35ã€‚
        2.  **æ ‡æ³¨å°ºå¯¸**ï¼šåœ¨å¯¹åº”çš„ X è½´å’Œ Y è½´æ–¹å‘ä¸Šæ·»åŠ æ ‡ç­¾ "7" å’Œ "5"ã€‚
        3.  **å‘ä¸Šå †å **ï¼šå°†è¿™ä¸ª 7x5 çš„åº•å±‚å¤åˆ¶ä¸€å±‚ï¼Œå¹¶å‘ä¸Šç§»åŠ¨ä¸€ä¸ªå•ä½ï¼ˆ2 * å°ç«‹æ–¹ä½“è¾¹é•¿ï¼‰çš„é«˜åº¦ã€‚ç¬¬äºŒå±‚ä½¿ç”¨ `TransformFromCopy` æˆ– `Create` æ•ˆæžœç”Ÿæˆï¼Œæ—¶é•¿ 1.5 ç§’ã€‚ç¬¬äºŒå±‚ç«‹æ–¹ä½“é¢œè‰²ä½¿ç”¨è“è‰² (#0000FF)ï¼Œä»£è¡¨ä¹˜ä»¥ 2ã€‚
        4.  **æ ‡æ³¨é«˜åº¦**ï¼šåœ¨ Z è½´æ–¹å‘æ·»åŠ æ ‡ç­¾ "2"ã€‚
        5.  æœ€ç»ˆå½¢æˆä¸€ä¸ª 7x5x2 çš„é•¿æ–¹ä½“ã€‚

*   **ç›¸æœºä¸ŽåŠ¨ç”»æ•ˆæžœ**
    *   åˆå§‹ç›¸æœºè§†è§’è®¾ç½®ä¸º `phi=75*DEGREES, theta=-45*DEGREES`ï¼Œèƒ½æ¸…æ™°çœ‹åˆ° XY å¹³é¢å’Œ Z è½´ã€‚
    *   åœ¨åˆ›å»º 7x5 åº•é¢æ—¶ï¼Œç›¸æœºå¯ä»¥è½»å¾®ä¿¯è§†ã€‚
    *   åœ¨å‘ä¸Šå †å æ—¶ï¼Œç›¸æœºå¯ä»¥ç¨å¾®è°ƒæ•´è§’åº¦ï¼ˆä¾‹å¦‚ï¼Œ`phi` å‡å°ä¸€ç‚¹ï¼Œ`theta` å˜åŒ–ä¸€ç‚¹ï¼‰æˆ–è½»å¾®æ‹‰è¿œï¼Œä»¥æ›´å¥½åœ°å±•ç¤ºç«‹ä½“ç»“æž„ã€‚ä½¿ç”¨ `self.move_camera(...)` å¹³æ»‘è¿‡æ¸¡ï¼Œæ—¶é•¿ä¸Žå †å åŠ¨ç”»åŒæ­¥ã€‚
    *   å·¦ä¾§æ–‡æœ¬ä¸Žå³ä¾§å›¾å½¢åŠ¨ç”»åŒæ­¥è¿›è¡Œï¼Œä¾‹å¦‚ï¼Œå½“æ˜¾ç¤º \(7 \times 5 = 35\) æ—¶ï¼Œå³ä¾§åˆšå¥½å®Œæˆ 7x5 åº•é¢çš„æž„å»ºã€‚å½“æ˜¾ç¤º \( \times 2 \) æ—¶ï¼Œå¼€å§‹å‘ä¸Šå †å ã€‚

---

### ã€åœºæ™¯ä¸‰ï¼šå¯è§†åŒ–è®¡ç®— 7 x (5 x 2)ã€‘

*   **èƒŒæ™¯ä¸Žå¸ƒå±€**
    *   èƒŒæ™¯å’Œå¸ƒå±€ä¸Žåœºæ™¯äºŒç±»ä¼¼ï¼šæµ…ç°æ¸å˜èƒŒæ™¯ï¼Œå·¦æ–‡å³å›¾ï¼Œä¸‰ç»´åæ ‡è½´ã€‚
    *   å³ä¸Šè§’æ˜¾ç¤ºåœºæ™¯ç¼–å·â€œ03â€ã€‚
    *   ä¸‰ç»´åæ ‡è½´è®¾ç½®ä¸Žåœºæ™¯äºŒç›¸åŒ (x: [0, 8], y: [0, 6], z: [0, 3])ï¼Œä½†åˆå§‹æž„å»ºçš„å¹³é¢å¯èƒ½ä¸åŒã€‚

*   **å†…å®¹å‘ˆçŽ°**
    *   **å·¦ä¾§æ–‡æœ¬ä¸Žå…¬å¼ï¼š**
        1.  é¦–å…ˆå‡ºçŽ°æ–‡æœ¬ï¼šâ€œè®¡ç®—æ–¹å¼äºŒï¼šå…ˆç®— \(5 \times 2\)â€ï¼Œä½¿ç”¨ `Write` æ•ˆæžœï¼Œæ—¶é•¿ 1 ç§’ã€‚
        2.  ä¸‹æ–¹å±•ç¤ºè®¡ç®—è¿‡ç¨‹ï¼š
            \[
            7 \times (5 \times 2)
            \]
            è¯¥å…¬å¼ä½¿ç”¨ LaTeX æ¸²æŸ“ï¼Œå…¶ä¸­ `(5 \times 2)` éƒ¨åˆ†é«˜äº®ï¼ˆæ·¡é»„è‰²èƒŒæ™¯ #FFFFE0ï¼‰ã€‚`FadeIn` æ•ˆæžœï¼Œæ—¶é•¿ 0.5 ç§’ã€‚
        3.  å†ä¸‹æ–¹æ˜¾ç¤ºä¸­é—´ç»“æžœï¼šâ€œ\( 5 \times 2 = 10 \)â€ ï¼Œä½¿ç”¨ `Write` æ•ˆæžœï¼Œæ—¶é•¿ 1 ç§’ã€‚
        4.  æœ€åŽæ˜¾ç¤ºå®Œæ•´è®¡ç®—ï¼šâ€œ\( = 7 \times 10 = 70 \)â€ ï¼Œä½¿ç”¨ `ReplacementTransform` ä»Ž `7 \times (5 \times 2)` å¹³æ»‘è¿‡æ¸¡ï¼Œæ—¶é•¿ 1.5 ç§’ã€‚
    *   **å³ä¾§ä¸‰ç»´å¯è§†åŒ–ï¼š**
        1.  **æž„å»º 5x2 "ä¾§é¢"**ï¼šä¾‹å¦‚ï¼Œåœ¨ YZ å¹³é¢ä¸Šï¼ˆæˆ– XY å¹³é¢ä¸Šï¼Œä½†ç»„ç»‡æ–¹å¼ä¸åŒï¼‰ï¼Œç”Ÿæˆä¸€ä¸ªç”± 5x2=10 ä¸ªå°ç«‹æ–¹ä½“ (`Cube`) ç»„æˆçš„ VGroupï¼ŒæŽ’åˆ—æˆ 5 è¡Œ 2 åˆ—ã€‚å°ç«‹æ–¹ä½“è¾¹é•¿ 0.5ã€‚ä½¿ç”¨ `Create` åŠ¨ç”»ï¼Œæ—¶é•¿ 1.5 ç§’ã€‚è¿™ç»„ç«‹æ–¹ä½“é¢œè‰²å¯ä»¥ç»“åˆç»¿è‰² (#008000) ä»£è¡¨ 5ï¼Œè“è‰² (#0000FF) ä»£è¡¨ 2ã€‚æˆ–è€…ç»Ÿä¸€ç”¨ä¸€ç§é¢œè‰²ï¼ˆå¦‚é’è‰² #00FFFFï¼‰è¡¨ç¤ºä¹˜ç§¯ 10ã€‚
        2.  **æ ‡æ³¨å°ºå¯¸**ï¼šåœ¨å¯¹åº”çš„ Y è½´å’Œ Z è½´ï¼ˆæˆ– X å’Œ Y è½´ï¼‰æ–¹å‘ä¸Šæ·»åŠ æ ‡ç­¾ "5" å’Œ "2"ã€‚
        3.  **æ²¿å¦ä¸€æ–¹å‘æ‰©å±•**ï¼šå°†è¿™ä¸ª 5x2 çš„â€œåˆ‡ç‰‡â€æ²¿ç€ X è½´ï¼ˆæˆ– Z è½´ï¼‰æ–¹å‘å¤åˆ¶æ‰©å±• 7 æ¬¡ï¼ˆæˆ–ç§»åŠ¨ 7 * å°ç«‹æ–¹ä½“è¾¹é•¿ çš„è·ç¦»ï¼‰ã€‚ä½¿ç”¨ `TransformFromCopy` æˆ– `Create` æ•ˆæžœé€å±‚ç”Ÿæˆï¼Œæ—¶é•¿ 2 ç§’ã€‚æ–°æ‰©å±•çš„ç»´åº¦ç”¨çº¢è‰² (#FF0000) ä»£è¡¨ 7ã€‚
        4.  **æ ‡æ³¨é•¿åº¦**ï¼šåœ¨ X è½´ï¼ˆæˆ– Z è½´ï¼‰æ–¹å‘æ·»åŠ æ ‡ç­¾ "7"ã€‚
        5.  æœ€ç»ˆä¹Ÿå½¢æˆä¸€ä¸ª 7x5x2 çš„é•¿æ–¹ä½“ã€‚**å…³é”®**ï¼šç¡®ä¿è¿™ä¸ªæœ€ç»ˆé•¿æ–¹ä½“çš„å½¢çŠ¶ã€å°ºå¯¸ã€é¢œè‰²ï¼ˆæ‰€æœ‰å°æ–¹å—æœ€ç»ˆç»Ÿä¸€æˆç°è‰² #808080ï¼‰å’Œç©ºé—´æ–¹ä½ä¸Žåœºæ™¯äºŒæœ€ç»ˆç”Ÿæˆçš„é•¿æ–¹ä½“å®Œå…¨ä¸€è‡´ã€‚

*   **ç›¸æœºä¸ŽåŠ¨ç”»æ•ˆæžœ**
    *   åˆå§‹ç›¸æœºè§†è§’å¯èƒ½éœ€è¦è°ƒæ•´ï¼ˆä¾‹å¦‚ `phi=75*DEGREES, theta=15*DEGREES`ï¼‰ï¼Œä»¥ä¾¿æ¸…æ™°å±•ç¤º 5x2 åˆ‡é¢çš„æž„å»ºã€‚
    *   åœ¨æ²¿ç¬¬ä¸‰ä¸ªç»´åº¦æ‰©å±•æ—¶ï¼Œç›¸æœºè¿›è¡Œå¹³æ»‘æ—‹è½¬å’Œ/æˆ–ç¼©æ”¾ (`move_camera`)ï¼Œæœ€ç»ˆå®šæ ¼åœ¨ä¸Žåœºæ™¯äºŒç»“æŸæ—¶**å®Œå…¨ç›¸åŒ**çš„è§†è§’å’Œç¼©æ”¾çº§åˆ«ï¼Œå¼ºè°ƒä¸¤ä¸ªè¿‡ç¨‹å¾—åˆ°äº†åŒä¸€ä¸ªç‰©ä½“ã€‚æ—‹è½¬åŠ¨ç”»æ—¶é•¿ä¸Žæ‰©å±•åŠ¨ç”»åŒæ­¥ã€‚
    *   å·¦å³å†…å®¹åŒæ ·ä¿æŒåŒæ­¥ã€‚

---

### ã€åœºæ™¯å››ï¼šå¯¹æ¯”ä¸Žç»“è®ºã€‘

*   **èƒŒæ™¯ä¸Žå¸ƒå±€**
    *   èƒŒæ™¯æ¢å¤ä¸ºç®€æ´çš„çº¯è‰²èƒŒæ™¯ï¼Œä¾‹å¦‚æµ…è“è‰² (#E0EFFF)ï¼Œæˆ–è€…ä½¿ç”¨åœºæ™¯ä¸€çš„æ¸å˜èƒŒæ™¯ã€‚
    *   å±å¹•ä¸­å¿ƒå±•ç¤ºæœ€ç»ˆçš„ 7x5x2 é•¿æ–¹ä½“ï¼ˆç°è‰² #808080ï¼‰ã€‚
    *   é•¿æ–¹ä½“å·¦å³ä¸¤ä¾§åˆ†åˆ«å±•ç¤ºä¸¤ç§è®¡ç®—è·¯å¾„çš„æœ€ç»ˆå…¬å¼ã€‚
    *   å±å¹•åº•éƒ¨ç•™å‡ºç©ºé—´å±•ç¤ºç»“è®ºæ€§æ–‡å­—ã€‚
    *   å³ä¸Šè§’æ˜¾ç¤ºåœºæ™¯ç¼–å·â€œ04â€ã€‚

*   **å†…å®¹å‘ˆçŽ°**
    *   **ä¸­å¿ƒå›¾å½¢**ï¼šæ˜¾ç¤ºåœ¨åœºæ™¯äºŒå’Œåœºæ™¯ä¸‰ä¸­æœ€ç»ˆå½¢æˆçš„ã€å®Œå…¨ç›¸åŒçš„ 7x5x2 é•¿æ–¹ä½“ã€‚å¯ä»¥ä½¿ç”¨ `FadeIn` æ•ˆæžœå‡ºçŽ°ï¼Œå¹¶å¯ä»¥æ·»åŠ ç¼“æ…¢æ—‹è½¬æ•ˆæžœï¼ˆ`Rotating`ï¼‰ï¼Œè®©è§‚ä¼—ä»Žä¸åŒè§’åº¦ç¡®è®¤å…¶å½¢æ€ã€‚æ—¶é•¿ 2 ç§’ã€‚
    *   **å·¦ä¾§å…¬å¼**ï¼šå±•ç¤º
        \[ (7 \times 5) \times 2 = 35 \times 2 = 70 \]
        ä½¿ç”¨ `Write` åŠ¨ç”»æ•ˆæžœï¼Œä»Žå·¦è‡³å³ä¾æ¬¡å‡ºçŽ°ï¼Œæ—¶é•¿ 1.5 ç§’ã€‚é¢œè‰²ä¸Žä¹‹å‰åœºæ™¯ä¿æŒä¸€è‡´ã€‚
    *   **å³ä¾§å…¬å¼**ï¼šå±•ç¤º
        \[ 7 \times (5 \times 2) = 7 \times 10 = 70 \]
        ä½¿ç”¨ `Write` åŠ¨ç”»æ•ˆæžœï¼Œä»Žå·¦è‡³å³ä¾æ¬¡å‡ºçŽ°ï¼Œæ—¶é•¿ 1.5 ç§’ã€‚é¢œè‰²ä¸Žä¹‹å‰åœºæ™¯ä¿æŒä¸€è‡´ã€‚
    *   **è¿žæŽ¥çº¿**ï¼šä»Žå·¦ä¾§å…¬å¼æŒ‡å‘ä¸­å¿ƒé•¿æ–¹ä½“ï¼Œå†ä»Žå³ä¾§å…¬å¼æŒ‡å‘ä¸­å¿ƒé•¿æ–¹ä½“ï¼Œç”»å‡ºä¸¤æ¡ç®­å¤´ï¼ˆ`Arrow`ï¼‰ï¼Œä½¿ç”¨ `Create` åŠ¨ç”»ï¼Œæ—¶é•¿ 1 ç§’ã€‚
    *   **æ ¸å¿ƒç­‰å¼**ï¼šåœ¨é•¿æ–¹ä½“ä¸‹æ–¹æˆ–å±å¹•ä¸­å¤®æ˜¾çœ¼ä½ç½®ï¼Œå†æ¬¡å±•ç¤ºæ ¸å¿ƒç­‰å¼ï¼š
        \[ (7 \times 5) \times 2 = 7 \times (5 \times 2) \]
        ä½¿ç”¨ `FadeIn` æ•ˆæžœï¼Œå¹¶å¯ä»¥å¯¹ç­‰å· `=` è¿›è¡Œå¼ºè°ƒï¼ˆä¾‹å¦‚æ”¾å¤§æˆ–é—ªçƒä¸€ä¸‹ï¼‰ã€‚æ—¶é•¿ 1 ç§’ã€‚
    *   **ç»“è®ºæ–‡å­—**ï¼šåœ¨å±å¹•æœ€ä¸‹æ–¹å‡ºçŽ°ç»“è®ºæ€§æ–‡å­—ï¼šâ€œä¸¤ç§ä¸åŒçš„è®¡ç®—é¡ºåºï¼Œå¾—åˆ°äº†å®Œå…¨ç›¸åŒçš„å‡ ä½•ä½“å’Œç»“æžœ (70)ã€‚è¿™ç›´è§‚åœ°è¯æ˜Žäº†ä¹˜æ³•ç»“åˆå¾‹ã€‚â€ æ–‡å­—é¢œè‰²ä¸ºé»‘è‰² (#000000)ï¼Œä½¿ç”¨ `FadeIn` æ•ˆæžœï¼Œæ—¶é•¿ 1.5 ç§’ã€‚

*   **ç›¸æœºä¸ŽåŠ¨ç”»æ•ˆæžœ**
    *   ç›¸æœºèšç„¦äºŽä¸­å¿ƒé•¿æ–¹ä½“å’Œä¸¤ä¾§çš„å…¬å¼ã€‚å¦‚æžœé•¿æ–¹ä½“æ—‹è½¬ï¼Œç›¸æœºä¿æŒç¨³å®šæˆ–è¿›è¡Œéžå¸¸ç¼“æ…¢çš„çŽ¯ç»•ç§»åŠ¨ã€‚
    *   æ•´ä½“åŠ¨ç”»æµç¨‹ï¼šå…ˆå‡ºçŽ°é•¿æ–¹ä½“ -> å†å‡ºçŽ°å·¦å³è®¡ç®—å…¬å¼ -> ç”»ç®­å¤´è¿žæŽ¥ -> å‡ºçŽ°æ ¸å¿ƒç­‰å¼ -> æœ€åŽå‡ºçŽ°ç»“è®ºæ–‡å­—ã€‚æ¯ä¸ªæ­¥éª¤ä¹‹é—´æœ‰ 0.3-0.5 ç§’çš„åœé¡¿ã€‚

---

### ã€å…¶ä»–æ•´ä½“è¦æ±‚ã€‘

*   **ç»Ÿä¸€è§†è§‰é£Žæ ¼**
    *   æ‰€æœ‰åœºæ™¯å‡é‡‡ç”¨é«˜æ¸…æ¸²æŸ“ã€‚
    *   æ‰€æœ‰æ•°å­¦å…¬å¼å‡ä½¿ç”¨ LaTeX `Tex` æˆ– `MathTex` ç²¾ç¡®æ¸²æŸ“ï¼Œä¿è¯æ¸…æ™°åº¦ã€‚
    *   é¢œè‰²æ–¹æ¡ˆï¼šèƒŒæ™¯è‰²è°ƒæŸ”å’Œï¼ˆæ¸å˜ç°ç™½æˆ–æµ…è“ï¼‰ï¼Œåæ ‡è½´ä¸ºæ·±ç°ï¼Œæ–‡å­—ä¸ºé»‘è‰²æˆ–æ·±è“ï¼Œä»£è¡¨æ•°å­— 7, 5, 2 çš„é¢œè‰²ï¼ˆçº¢ã€ç»¿ã€è“ï¼‰åœ¨åœºæ™¯äºŒã€ä¸‰ä¸­ä¿æŒä¸€è‡´æ€§ï¼Œæœ€ç»ˆç»„åˆçš„é•¿æ–¹ä½“ä½¿ç”¨ä¸­æ€§è‰²ï¼ˆå¦‚ç°è‰²ï¼‰ã€‚é‡ç‚¹å†…å®¹ï¼ˆå¦‚é«˜äº®å…¬å¼éƒ¨åˆ†ã€ç­‰å·ã€ç»“è®ºæ–‡å­—ï¼‰å¯é€‚å½“ä½¿ç”¨é†’ç›®é¢œè‰²æˆ–æ•ˆæžœã€‚åœºæ™¯ç¼–å·ç»Ÿä¸€é£Žæ ¼ã€‚
*   **åŠ¨ç”»ä¸Žè½¬åœº**
    *   åœºæ™¯ä¹‹é—´çš„è¿‡æ¸¡ä½¿ç”¨ç®€æ´çš„ `FadeOut` æ—§åœºæ™¯å…ƒç´ ã€`FadeIn` æ–°åœºæ™¯å…ƒç´ ï¼Œæˆ–è€…ç›´æŽ¥æ›¿æ¢ï¼Œä¿æŒæµç•…ã€‚è¿‡æ¸¡æ—¶é—´çº¦ 0.5 - 1 ç§’ã€‚
    *   ç›¸æœºè¿åŠ¨ï¼ˆæ—‹è½¬ã€å¹³ç§»ã€ç¼©æ”¾ï¼‰å¹³æ»‘è‡ªç„¶ï¼Œé¿å…çªå…€è·³åŠ¨ï¼Œè¿åŠ¨é€Ÿåº¦é€‚ä¸­ï¼Œç¡®ä¿è§‚ä¼—èƒ½è·Ÿä¸Šå›¾å½¢å’Œé€»è¾‘çš„å˜åŒ–ã€‚
    *   æ‰€æœ‰åŠ¨ç”»ï¼ˆ`Create`, `Write`, `FadeIn`, `ReplacementTransform`, `TransformFromCopy`, `Rotating`ï¼‰çš„æ—¶é•¿å’Œå»¶è¿Ÿç²¾å¿ƒè®¾è®¡ï¼Œä¸Žè§£è¯´èŠ‚å¥åŒ¹é…ï¼ˆå¦‚æžœåŽç»­é…éŸ³ï¼‰ï¼Œä¿è¯ä¿¡æ¯ä¼ é€’çš„æœ‰æ•ˆæ€§ã€‚

---
```

## ä»£ç 

```
# -*- coding: utf-8 -*-
import os
import numpy as np
import requests
from contextlib import contextmanager
from manim import *
import hashlib
from moviepy import AudioFileClip # Correct import for AudioFileClip
import manimpango # For font checking

# --- Custom Colors ---
MY_LIGHT_GRAY = "#DDDDDD"
MY_WHITE = "#FFFFFF"
MY_DARK_GRAY = "#555555"
MY_BLACK = "#000000"
MY_DARK_BLUE = "#00008B"
MY_RED_STR = "FF0000" # Hex code without # for LaTeX color
MY_GREEN_STR = "008000"
MY_BLUE_STR = "0000FF"
MY_RED = "#" + MY_RED_STR
MY_GREEN = "#" + MY_GREEN_STR
MY_BLUE = "#" + MY_BLUE_STR
MY_YELLOW_HIGHLIGHT = "#FFFFE0" # For formula highlight background
MY_ORANGE = "#FFA500" # For (7x5) cubes
MY_CYAN = "#00FFFF" # For (5x2) cubes
MY_GRAY_CUBE = "#808080" # Final cube color
MY_LIGHT_BLUE_BG = "#E0EFFF" # Scene 4 background

# --- Font Check ---
DEFAULT_FONT = "Noto Sans CJK SC" # Or another preferred CJK font
final_font = None
available_fonts = manimpango.list_fonts()
if DEFAULT_FONT in available_fonts:
    print(f"å­—ä½“ '{DEFAULT_FONT}' å·²æ‰¾åˆ°ã€‚")
    final_font = DEFAULT_FONT
else:
    print(f"è­¦å‘Š: å­—ä½“ '{DEFAULT_FONT}' æœªæ‰¾åˆ°ã€‚æ­£åœ¨å°è¯•å¤‡ç”¨å­—ä½“...")
    fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei", "Arial Unicode MS"]
    found_fallback = False
    for font in fallback_fonts:
        if font in available_fonts:
            print(f"å·²åˆ‡æ¢åˆ°å¤‡ç”¨å­—ä½“: '{font}'")
            final_font = font
            found_fallback = True
            break
    if not found_fallback:
        print(f"è­¦å‘Š: æœªæ‰¾åˆ°æŒ‡å®šçš„ '{DEFAULT_FONT}' æˆ–ä»»ä½•å¤‡ç”¨ä¸­æ–‡å­—ä½“ã€‚å°†ä½¿ç”¨ Manim é»˜è®¤å­—ä½“ï¼Œä¸­æ–‡å¯èƒ½æ— æ³•æ­£ç¡®æ˜¾ç¤ºã€‚")

# --- TTS Caching Setup ---
CACHE_DIR = "tts_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

class CustomVoiceoverTracker:
    """Tracks audio path and duration for TTS."""
    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration

def get_cache_filename(text):
    """Generates a unique filename based on the text hash."""
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")

@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    """
    Fetches TTS audio, caches it, and provides path and duration.
    Usage: with custom_voiceover_tts("text") as tracker: ...
    """
    cache_file = get_cache_filename(text)
    audio_file = cache_file  # Initialize audio_file

    if os.path.exists(cache_file):
        print(f"Using cached TTS for: {text[:30]}...")
    else:
        print(f"Requesting TTS for: {text[:30]}...")
        try:
            # URL encode the input text to handle special characters
            input_text_encoded = requests.utils.quote(text)
            url = f"{base_url}?token={token}&input={input_text_encoded}"

            response = requests.get(url, stream=True, timeout=60)  # Added timeout
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)

            with open(cache_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            audio_file = cache_file
            print("TTS downloaded and cached.")

        except requests.exceptions.RequestException as e:
            print(f"TTS API request failed: {e}")
            # Fallback: create a dummy tracker with zero duration
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return  # Exit context manager

    # Ensure audio file exists before processing with MoviePy
    if audio_file and os.path.exists(audio_file):
        try:
            clip = AudioFileClip(audio_file)
            duration = clip.duration
            clip.close()
            print(f"Audio duration: {duration:.2f}s")
            tracker = CustomVoiceoverTracker(audio_file, duration)
        except Exception as e:
            print(f"Error processing audio file {audio_file}: {e}")
            # Fallback if audio file is corrupted or invalid
            tracker = CustomVoiceoverTracker(None, 0)
    else:
        # Fallback if audio file was not created or found
        print(f"TTS audio file not found or not created: {audio_file}")
        tracker = CustomVoiceoverTracker(None, 0)

    try:
        yield tracker
    finally:
        # No cleanup needed here as we are caching
        pass

# --- Custom TeX Template for colorbox/color ---
# Needed for \colorbox and \color[HTML]
# DO NOT include \documentclass here!
color_support_template = TexTemplate(
    preamble=r"""
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[HTML]{xcolor} % Enable HTML colors and \color / \colorbox
\usepackage{graphicx}
% Add other necessary packages here if needed
"""
)

# --- Combined Scene ---
class CombinedScene(ThreeDScene): # Inherit from ThreeDScene for 3D capabilities

    # Store final objects to carry over if needed (e.g., for comparison)
    final_cubes_s2 = None
    final_axes_s2 = None
    final_labels_s2 = None
    final_dim_labels_s2 = None
    final_cubes_s3 = None
    final_axes_s3 = None
    final_labels_s3 = None
    final_dim_labels_s3 = None

    def setup(self):
        # Set default font if found
        if final_font:
            Text.set_default(font=final_font)
        # Set default TexTemplate for the scene if needed globally
        # Tex.set_default(tex_template=color_support_template)
        # MathTex.set_default(tex_template=color_support_template)
        # Or pass it individually where needed

        # Initial camera setup for 3D scene (can be overridden in scenes)
        self.set_camera_orientation(phi=0 * DEGREES, theta=-90 * DEGREES) # Start looking straight down

    def construct(self):
        self.play_scene_01()
        self.clear_and_reset() # Custom clear for 3D

        self.play_scene_02()
        self.clear_and_reset()

        self.play_scene_03()
        self.clear_and_reset()

        self.play_scene_04()
        self.clear_and_reset()

        # Final message
        self.set_camera_orientation(phi=0, theta=-PI/2) # Reset to 2D-like view
        final_message = Text("åŠ¨ç”»ç»“æŸï¼Œæ„Ÿè°¢è§‚çœ‹ï¼ ðŸ˜„", font_size=48, color=MY_BLACK)
        # Use a 2D background for the final message
        bg_final = Rectangle(width=config.frame_width, height=config.frame_height, fill_color=MY_LIGHT_BLUE_BG, fill_opacity=1, stroke_width=0).set_z_index(-10)
        # Add fixed in frame mobjects for 2D overlays in 3D scene
        self.add_fixed_in_frame_mobjects(bg_final)
        self.add_fixed_in_frame_mobjects(final_message) # Make message fixed

        self.play(FadeIn(final_message))
        self.wait(2)

    def get_scene_number(self, number_str):
        """Creates and positions the scene number, fixed to the frame."""
        scene_num = Text(number_str, font_size=24, color=MY_DARK_GRAY)
        scene_num.to_corner(UR, buff=0.3)
        scene_num.set_z_index(20) # Ensure above other elements
        # For 3D scenes, make it fixed in frame
        self.add_fixed_in_frame_mobjects(scene_num)
        return scene_num

    def create_gradient_background(self, color1, color2):
        """Creates a gradient background fixed to the frame."""
        # Create a 2D rectangle and add it as a fixed-in-frame mobject
        bg = Rectangle(
            width=config.frame_width * 2, # Make larger to avoid edge issues during rotation
            height=config.frame_height * 2,
            stroke_width=0,
            fill_opacity=1
        )
        # Apply gradient fill using list of colors (default is vertical DOWN)
        # Use set_fill which accepts a list for gradient
        bg.set_fill(color=[color1, color2], opacity=1)
        # Manually set the gradient direction if needed (e.g., vertical)
        # bg.set_sheen_direction(DOWN) # Default is DOWN
        bg.set_z_index(-10)
        # Add fixed in frame so it doesn't move with 3D camera
        self.add_fixed_in_frame_mobjects(bg)
        return bg

    def clear_and_reset(self):
        """Clears all mobjects and resets the camera for a new scene."""
        # *** FIX: Access fixed_in_frame_mobjects via self.camera ***
        all_mobs_to_clear = list(self.mobjects) + list(self.camera.fixed_in_frame_mobjects)

        # Clear updaters from all mobjects
        for mob in all_mobs_to_clear:
            # Check if the mobject exists and has updaters before clearing
            if mob is not None and hasattr(mob, 'get_updaters') and mob.get_updaters():
                mob.clear_updaters()

        # Fade out all mobjects (including fixed ones temporarily)
        # Use Group for potentially mixed object types
        valid_mobs = [m for m in all_mobs_to_clear if m is not None]
        if valid_mobs:
            self.play(FadeOut(Group(*valid_mobs)), run_time=0.5)

        # Clear the lists
        self.mobjects.clear()
        # *** FIX: Clear fixed_in_frame_mobjects via self.camera ***
        self.camera.fixed_in_frame_mobjects.clear()

        # Reset camera for 3D scene to a default state
        self.set_camera_orientation(phi=0 * DEGREES, theta=-90 * DEGREES) # Reset to top-down view
        # Reset zoom/distance and center
        self.move_camera(frame_center=ORIGIN, zoom=1.0, added_anims=[]) # Use move_camera to reset zoom

        self.wait(0.1)

    # --- Scene Implementations ---
    def play_scene_01(self):
        """Scene 1: Title and Problem Introduction"""
        scene_num = self.get_scene_number("01")
        bg = self.create_gradient_background(MY_LIGHT_GRAY, MY_WHITE)

        title = Text("å›¾å½¢åŒ–è¯æ˜Žï¼šä¹˜æ³•ç»“åˆå¾‹", font_size=48, color=MY_BLACK)
        title.move_to(UP * 2)

        # Formula with colored numbers - requires custom TeX template
        # Use the STR versions of colors (without #) for LaTeX
        formula_str = r"{\color[HTML]{%s} 7} \times {\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2} = {\color[HTML]{%s} 7} \times ({\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2})" % (
            MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR, MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR
        )
        # Pass the custom template here
        formula = MathTex(formula_str, font_size=42, color=MY_DARK_BLUE, tex_template=color_support_template)
        formula.next_to(title, DOWN, buff=0.8)

        # Add elements as fixed in frame for this 2D-like scene
        self.add_fixed_in_frame_mobjects(title)
        self.add_fixed_in_frame_mobjects(formula)

        voice_text_01 = "å¤§å®¶å¥½ï¼æœ¬æœŸè§†é¢‘ï¼Œæˆ‘ä»¬å°†ç”¨å›¾å½¢åŒ–çš„æ–¹å¼æ¥è¯æ˜Žä¹˜æ³•çš„ç»“åˆå¾‹ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬è¦è¯æ˜Ž 7 ä¹˜ä»¥ 5 å†ä¹˜ä»¥ 2ï¼Œç­‰äºŽ 7 ä¹˜ä»¥ 5 ä¹˜ä»¥ 2 çš„ç§¯ã€‚"
        with custom_voiceover_tts(voice_text_01) as tracker:
            audio_duration = tracker.duration if tracker.audio_path else 0
            if tracker.audio_path and audio_duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 1 TTS failed or has zero duration.")

            subtitle_voice = Text(voice_text_01, font_size=32, color=MY_BLACK, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=0.5)
            self.add_fixed_in_frame_mobjects(subtitle_voice) # Fixed subtitle

            anim_title_duration = 1.5
            anim_formula_delay = 0.5
            anim_formula_duration = 1.0
            fade_out_duration = 1.0
            # Calculate total animation time BEFORE fade out
            total_anim_duration_planned = anim_title_duration + anim_formula_delay + anim_formula_duration

            # Use FadeIn for Text as Write might cause issues
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5), # Subtitle appears first
                    FadeIn(title, shift=UP*0.2), # Use FadeIn for title
                    lag_ratio=0.0
                ),
                run_time=anim_title_duration
            )
            self.wait(anim_formula_delay)
            # Use Write for MathTex as it's a VMobject
            self.play(Write(formula), run_time=anim_formula_duration)

            # Calculate wait time based on audio duration vs animation time
            if audio_duration > 0:
                elapsed_time = total_anim_duration_planned
                time_for_fadeout = fade_out_duration
                remaining_time = audio_duration - elapsed_time - time_for_fadeout
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                # If no audio, just wait a bit after animations
                self.wait(2.0)

            # Fade out the voiceover subtitle
            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(1)


    def play_scene_02(self):
        """Scene 2: (7x5) x 2 Visualization"""
        scene_num = self.get_scene_number("02")
        bg = self.create_gradient_background(MY_LIGHT_GRAY, MY_WHITE)

        initial_phi = 75 * DEGREES
        initial_theta = -45 * DEGREES
        initial_distance = 15
        self.set_camera_orientation(phi=initial_phi, theta=initial_theta, distance=initial_distance)

        left_zone_x = -config.frame_width / 4
        right_zone_x = config.frame_width / 4

        # --- Left Text & Formulas (Fixed in Frame) ---
        text_title = Text("è®¡ç®—æ–¹å¼ä¸€ï¼šå…ˆç®— 7 Ã— 5", font_size=30, color=MY_BLACK)
        text_title.move_to([left_zone_x, 3, 0]).align_to([-config.frame_width/2 + 1, 0, 0], LEFT)
        formula_s2_1_str = r"({\color[HTML]{%s} 7} \times {\color[HTML]{%s} 5}) \times {\color[HTML]{%s} 2}" % (MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR)
        formula_s2_1 = MathTex(formula_s2_1_str, font_size=36, color=MY_DARK_BLUE, tex_template=color_support_template)
        formula_s2_1.next_to(text_title, DOWN, buff=0.5, aligned_edge=LEFT)
        formula_s2_2_str = r"{\color[HTML]{%s} 7} \times {\color[HTML]{%s} 5} = 35" % (MY_RED_STR, MY_GREEN_STR)
        formula_s2_2 = MathTex(formula_s2_2_str, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_s2_2.next_to(formula_s2_1, DOWN, buff=0.5, aligned_edge=LEFT)
        formula_s2_3_str = r"= 35 \times {\color[HTML]{%s} 2} = 70" % MY_BLUE_STR
        formula_s2_3 = MathTex(formula_s2_3_str, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_s2_3.move_to(formula_s2_1).align_to(formula_s2_1, LEFT)
        left_group = VGroup(text_title, formula_s2_1, formula_s2_2)
        self.add_fixed_in_frame_mobjects(left_group)
        formula_s2_2.set_opacity(0)
        # highlight_rect created later

        # --- Right 3D Visualization ---
        axes = ThreeDAxes(
            x_range=[0, 8, 2], y_range=[0, 6, 2], z_range=[0, 3, 1],
            x_length=7, y_length=5, z_length=3,
            axis_config={"color": MY_DARK_GRAY, "include_tip": False, "stroke_width": 2, "include_numbers": True, "decimal_number_config": {"num_decimal_places": 0}},
            x_axis_config={"color": MY_RED}, y_axis_config={"color": MY_GREEN}, z_axis_config={"color": MY_BLUE},
        )
        axes.move_to([right_zone_x, 0, 0])
        labels = axes.get_axis_labels(
            x_label=Tex("7", color=MY_RED), y_label=Tex("5", color=MY_GREEN), z_label=Tex("2", color=MY_BLUE)
        )

        # *** FIX: Add axes and labels to the scene explicitly first ***
        self.add(axes, labels)
        # Make them initially invisible if FadeIn animation is desired
        axes.set_opacity(0)
        labels.set_opacity(0)

        # Cube properties
        cube_size = 0.5
        gap = 0.0
        base_layer = VGroup()
        x_offset = - (7 - 1) * (cube_size + gap) / 2
        y_offset = - (5 - 1) * (cube_size + gap) / 2
        z_offset = cube_size / 2
        for i in range(7):
            for j in range(5):
                cube = Cube(side_length=cube_size, fill_opacity=0.8, stroke_width=0.5, stroke_color=MY_DARK_GRAY)
                x_pos = i * (cube_size + gap) + x_offset
                y_pos = j * (cube_size + gap) + y_offset
                z_pos = z_offset
                cube.move_to(axes.get_origin() + RIGHT * x_pos + UP * y_pos + OUT * (z_pos - cube_size/2))
                cube.set_fill(MY_ORANGE)
                base_layer.add(cube)
        top_layer = base_layer.copy()
        top_layer.shift(OUT * (cube_size + gap))
        top_layer.set_fill(MY_BLUE)
        # cubes_group = VGroup(base_layer, top_layer) # Group for potential later use

        # --- Animations ---
        voice_text_02 = "çŽ°åœ¨æ¥çœ‹ç¬¬ä¸€ç§è®¡ç®—æ–¹å¼ï¼Œæˆ‘ä»¬å…ˆè®¡ç®— 7 ä¹˜ä»¥ 5ã€‚åœ¨å³è¾¹çš„ä¸‰ç»´ç©ºé—´é‡Œï¼Œæˆ‘ä»¬æž„å»ºä¸€ä¸ª 7 è¡Œ 5 åˆ—çš„åº•å±‚ï¼Œç”± 35 ä¸ªå°æ–¹å—ç»„æˆï¼Œä»£è¡¨ 7 ä¹˜ä»¥ 5 ç­‰äºŽ 35ã€‚æŽ¥ç€ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªåº•å±‚å‘ä¸Šå †å ä¸€å±‚ï¼Œä»£è¡¨ä¹˜ä»¥ 2ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ª 7 ä¹˜ 5 ä¹˜ 2 çš„é•¿æ–¹ä½“ï¼Œæ€»å…±æœ‰ 35 ä¹˜ä»¥ 2ï¼Œç­‰äºŽ 70 ä¸ªå°æ–¹å—ã€‚"
        with custom_voiceover_tts(voice_text_02) as tracker:
            audio_duration = tracker.duration if tracker.audio_path else 0
            if tracker.audio_path and audio_duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else: print("Warning: Scene 2 TTS failed or has zero duration.")

            subtitle_voice = Text(voice_text_02, font_size=32, color=MY_BLACK, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=0.5)
            self.add_fixed_in_frame_mobjects(subtitle_voice)

            anim_intro_duration = 1.5
            anim_base_duration = 2.0
            anim_stack_duration = 1.5
            fade_out_duration = 1.0

            target_highlight = VGroup(formula_s2_1.get_part_by_tex("7"), formula_s2_1.get_part_by_tex("5"), formula_s2_1.get_part_by_tex(r"\times")[0])
            highlight_rect = SurroundingRectangle(target_highlight, buff=0.05, color=MY_YELLOW_HIGHLIGHT, fill_color=MY_YELLOW_HIGHLIGHT, fill_opacity=0.3, stroke_width=0)
            self.add_fixed_in_frame_mobjects(highlight_rect)
            highlight_rect.set_opacity(0)

            # *** FIX: Animate FadeIn for already added axes/labels ***
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    FadeIn(axes), # FadeIn the axes
                    FadeIn(labels), # FadeIn the labels
                    FadeIn(text_title),
                    Write(formula_s2_1),
                    FadeIn(highlight_rect),
                    lag_ratio=0.0
                ),
                run_time=anim_intro_duration
            )

            self.play(
                AnimationGroup(
                    Create(base_layer, lag_ratio=0.01),
                    FadeIn(formula_s2_2, shift=DOWN*0.2),
                    lag_ratio=0.1
                ),
                run_time=anim_base_duration
            )

            self.move_camera(phi=65 * DEGREES, theta=-55 * DEGREES, distance=initial_distance * 1.1, run_time=anim_stack_duration)
            self.play(
                AnimationGroup(
                    TransformFromCopy(base_layer, top_layer),
                    ReplacementTransform(VGroup(formula_s2_1, highlight_rect), formula_s2_3),
                    FadeOut(formula_s2_2),
                    lag_ratio=0.1
                ),
                run_time=anim_stack_duration
            )

            total_anim_time = anim_intro_duration + anim_base_duration + anim_stack_duration
            if audio_duration > 0:
                remaining_time = audio_duration - total_anim_time - fade_out_duration
                if remaining_time > 0: self.wait(remaining_time)
            else: self.wait(1.5)

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(1)
        CombinedScene.final_cubes_s2 = VGroup(base_layer, top_layer)
        CombinedScene.final_axes_s2 = axes
        CombinedScene.final_labels_s2 = labels

    def play_scene_03(self):
        """Scene 3: 7 x (5x2) Visualization"""
        scene_num = self.get_scene_number("03")
        bg = self.create_gradient_background(MY_LIGHT_GRAY, MY_WHITE)

        initial_phi = 75 * DEGREES
        initial_theta = 15 * DEGREES
        initial_distance = 15
        self.set_camera_orientation(phi=initial_phi, theta=initial_theta, distance=initial_distance)

        left_zone_x = -config.frame_width / 4
        right_zone_x = config.frame_width / 4

        # --- Left Text & Formulas (Fixed in Frame) ---
        text_title_s3 = Text("è®¡ç®—æ–¹å¼äºŒï¼šå…ˆç®— 5 Ã— 2", font_size=30, color=MY_BLACK)
        text_title_s3.move_to([left_zone_x, 3, 0]).align_to([-config.frame_width/2 + 1, 0, 0], LEFT)
        formula_s3_1_str = r"{\color[HTML]{%s} 7} \times ({\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2})" % (MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR)
        formula_s3_1 = MathTex(formula_s3_1_str, font_size=36, color=MY_DARK_BLUE, tex_template=color_support_template)
        formula_s3_1.next_to(text_title_s3, DOWN, buff=0.5, aligned_edge=LEFT)
        formula_s3_2_str = r"{\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2} = 10" % (MY_GREEN_STR, MY_BLUE_STR)
        formula_s3_2 = MathTex(formula_s3_2_str, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_s3_2.next_to(formula_s3_1, DOWN, buff=0.5, aligned_edge=LEFT)
        formula_s3_3_str = r"= {\color[HTML]{%s} 7} \times 10 = 70" % MY_RED_STR
        formula_s3_3 = MathTex(formula_s3_3_str, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_s3_3.move_to(formula_s3_1).align_to(formula_s3_1, LEFT)
        left_group_s3 = VGroup(text_title_s3, formula_s3_1, formula_s3_2)
        self.add_fixed_in_frame_mobjects(left_group_s3)
        formula_s3_2.set_opacity(0)
        # highlight_rect_s3 created later

        # --- Right 3D Visualization ---
        axes_s3 = ThreeDAxes(
            x_range=[0, 8, 2], y_range=[0, 6, 2], z_range=[0, 3, 1],
            x_length=7, y_length=5, z_length=3,
            axis_config={"color": MY_DARK_GRAY, "include_tip": False, "stroke_width": 2, "include_numbers": True, "decimal_number_config": {"num_decimal_places": 0}},
            x_axis_config={"color": MY_RED}, y_axis_config={"color": MY_GREEN}, z_axis_config={"color": MY_BLUE},
        )
        axes_s3.move_to([right_zone_x, 0, 0])
        labels_s3 = axes_s3.get_axis_labels(
            x_label=Tex("7", color=MY_RED), y_label=Tex("5", color=MY_GREEN), z_label=Tex("2", color=MY_BLUE)
        )

        # *** FIX: Add axes and labels to the scene explicitly first ***
        self.add(axes_s3, labels_s3)
        axes_s3.set_opacity(0)
        labels_s3.set_opacity(0)


        cube_size = 0.5
        gap = 0.0
        slice_layer = VGroup()
        x_offset_s3 = - (7 - 1) * (cube_size + gap) / 2
        y_offset_s3 = - (5 - 1) * (cube_size + gap) / 2
        z_offset_s3 = - (2 - 1) * (cube_size + gap) / 2
        first_slice_x = x_offset_s3 + cube_size / 2
        for j in range(5):
            for k in range(2):
                cube = Cube(side_length=cube_size, fill_opacity=0.8, stroke_width=0.5, stroke_color=MY_DARK_GRAY)
                x_pos = first_slice_x
                y_pos = j * (cube_size + gap) + y_offset_s3 + cube_size / 2
                z_pos = k * (cube_size + gap) + z_offset_s3 + cube_size / 2
                cube.move_to(axes_s3.get_origin() + RIGHT * x_pos + UP * y_pos + OUT * z_pos)
                cube.set_fill(MY_CYAN)
                slice_layer.add(cube)

        full_block = VGroup()
        all_slices = []
        for i in range(7):
            new_slice = slice_layer.copy()
            x_shift = i * (cube_size + gap)
            actual_shift = RIGHT * x_shift
            new_slice.shift(actual_shift)
            new_slice.set_fill(MY_GRAY_CUBE)
            full_block.add(new_slice)
            all_slices.append(new_slice)

        # --- Animations ---
        voice_text_03 = "æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¢ä¸€ç§æ–¹å¼ï¼Œå…ˆè®¡ç®—æ‹¬å·é‡Œçš„ 5 ä¹˜ä»¥ 2ã€‚æˆ‘ä»¬åœ¨ YZ å¹³é¢ä¸Šæž„å»ºä¸€ä¸ª 5 è¡Œ 2 åˆ—çš„åˆ‡ç‰‡ï¼Œç”± 10 ä¸ªå°æ–¹å—ç»„æˆï¼Œä»£è¡¨ 5 ä¹˜ä»¥ 2 ç­‰äºŽ 10ã€‚ç„¶åŽï¼Œæˆ‘ä»¬å°†è¿™ä¸ªåˆ‡ç‰‡æ²¿ç€ X è½´æ–¹å‘æ‰©å±• 7 æ¬¡ï¼Œä»£è¡¨ä¹˜ä»¥ 7ã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬åŒæ ·å¾—åˆ°äº†ä¸€ä¸ª 7 ä¹˜ 5 ä¹˜ 2 çš„é•¿æ–¹ä½“ï¼Œæ€»å…±æœ‰ 7 ä¹˜ä»¥ 10ï¼Œç­‰äºŽ 70 ä¸ªå°æ–¹å—ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸ªé•¿æ–¹ä½“å’Œä¸Šä¸€ç§æ–¹æ³•å¾—åˆ°çš„æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼"
        with custom_voiceover_tts(voice_text_03) as tracker:
            audio_duration = tracker.duration if tracker.audio_path else 0
            if tracker.audio_path and audio_duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else: print("Warning: Scene 3 TTS failed or has zero duration.")

            subtitle_voice = Text(voice_text_03, font_size=32, color=MY_BLACK, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=0.5)
            self.add_fixed_in_frame_mobjects(subtitle_voice)

            anim_intro_duration = 1.5
            anim_slice_duration = 1.5
            anim_extend_duration = 2.0
            fade_out_duration = 1.0

            target_highlight_s3 = VGroup(formula_s3_1.get_part_by_tex("5"), formula_s3_1.get_part_by_tex("2"), formula_s3_1.get_part_by_tex(r"\times")[1])
            highlight_rect_s3 = SurroundingRectangle(target_highlight_s3, buff=0.05, color=MY_YELLOW_HIGHLIGHT, fill_color=MY_YELLOW_HIGHLIGHT, fill_opacity=0.3, stroke_width=0)
            self.add_fixed_in_frame_mobjects(highlight_rect_s3)
            highlight_rect_s3.set_opacity(0)

            # *** FIX: Animate FadeIn for already added axes/labels ***
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    FadeIn(axes_s3), # FadeIn the axes
                    FadeIn(labels_s3), # FadeIn the labels
                    FadeIn(text_title_s3),
                    Write(formula_s3_1),
                    FadeIn(highlight_rect_s3),
                    lag_ratio=0.0
                ),
                run_time=anim_intro_duration
            )

            self.play(
                AnimationGroup(
                    Create(slice_layer, lag_ratio=0.05),
                    FadeIn(formula_s3_2, shift=DOWN*0.2),
                    lag_ratio=0.1
                ),
                run_time=anim_slice_duration
            )

            final_phi = 65 * DEGREES
            final_theta = -55 * DEGREES
            final_distance = initial_distance * 1.1
            self.move_camera(phi=final_phi, theta=final_theta, distance=final_distance, run_time=anim_extend_duration)
            self.play(
                AnimationGroup(
                    LaggedStart(*[TransformFromCopy(slice_layer if i==0 else all_slices[i-1], s) for i, s in enumerate(all_slices)], lag_ratio=0.1),
                    ReplacementTransform(VGroup(formula_s3_1, highlight_rect_s3), formula_s3_3),
                    FadeOut(formula_s3_2),
                    FadeOut(slice_layer, run_time=0.1),
                    lag_ratio=0.1
                ),
                run_time=anim_extend_duration
            )

            total_anim_time = anim_intro_duration + anim_slice_duration + anim_extend_duration
            if audio_duration > 0:
                remaining_time = audio_duration - total_anim_time - fade_out_duration
                if remaining_time > 0: self.wait(remaining_time)
            else: self.wait(1.5)

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(1)
        CombinedScene.final_cubes_s3 = full_block
        CombinedScene.final_axes_s3 = axes_s3
        CombinedScene.final_labels_s3 = labels_s3

    def play_scene_04(self):
        """Scene 4: Comparison and Conclusion"""
        scene_num = self.get_scene_number("04")
        # Use a plain background fixed in frame
        bg = Rectangle(width=config.frame_width*2, height=config.frame_height*2, fill_color=MY_LIGHT_BLUE_BG, fill_opacity=1, stroke_width=0).set_z_index(-10)
        self.add_fixed_in_frame_mobjects(bg)

        # Camera: Stable view, matching the end view of Scene 2 & 3
        final_phi = 65 * DEGREES
        final_theta = -55 * DEGREES
        final_distance = 15 * 1.1 # Match end distance
        self.set_camera_orientation(phi=final_phi, theta=final_theta, distance=final_distance)

        # --- Center: Final Cube ---
        # Use the cube from scene 3 (or scene 2, they should be identical)
        # Ensure it's colored gray
        if CombinedScene.final_cubes_s3:
             # Need to ensure the object exists before copying
            final_cube_display = CombinedScene.final_cubes_s3.copy()
        elif CombinedScene.final_cubes_s2:
            final_cube_display = CombinedScene.final_cubes_s2.copy()
        else:
            # Fallback: create a dummy cube if previous scenes failed
            print("Warning: Could not retrieve final cubes from previous scenes.")
            final_cube_display = Cube() # Placeholder

        final_cube_display.set_fill(MY_GRAY_CUBE, opacity=0.8)
        final_cube_display.move_to(ORIGIN) # Center it in 3D space

        # --- Left Formula (Fixed) ---
        formula_left_str1 = r"({\color[HTML]{%s} 7} \times {\color[HTML]{%s} 5}) \times {\color[HTML]{%s} 2}" % (MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR)
        formula_left_str2 = r"= 35 \times {\color[HTML]{%s} 2} = 70" % MY_BLUE_STR
        formula_left1 = MathTex(formula_left_str1, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_left2 = MathTex(formula_left_str2, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_left_group = VGroup(formula_left1, formula_left2).arrange(DOWN, aligned_edge=LEFT)
        # Position fixed relative to the frame
        formula_left_group.to_corner(LEFT + UP, buff=1.5)

        # --- Right Formula (Fixed) ---
        formula_right_str1 = r"{\color[HTML]{%s} 7} \times ({\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2})" % (MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR)
        formula_right_str2 = r"= {\color[HTML]{%s} 7} \times 10 = 70" % MY_RED_STR
        formula_right1 = MathTex(formula_right_str1, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_right2 = MathTex(formula_right_str2, font_size=36, color=MY_BLACK, tex_template=color_support_template)
        formula_right_group = VGroup(formula_right1, formula_right2).arrange(DOWN, aligned_edge=LEFT)
        # Position fixed relative to the frame
        formula_right_group.to_corner(RIGHT + UP, buff=1.5)

        # --- Arrows (Fixed) ---
        # Arrows need to connect fixed formulas to the 3D cube's projected position
        # Draw arrows from formula groups towards the center (ORIGIN in fixed frame)
        arrow_left = Arrow(formula_left_group.get_right(), ORIGIN + LEFT*2, buff=0.2, color=MY_DARK_GRAY)
        arrow_right = Arrow(formula_right_group.get_left(), ORIGIN + RIGHT*2, buff=0.2, color=MY_DARK_GRAY)

        # --- Core Equality (Fixed) ---
        core_eq_str = r"({\color[HTML]{%s} 7} \times {\color[HTML]{%s} 5}) \times {\color[HTML]{%s} 2} = {\color[HTML]{%s} 7} \times ({\color[HTML]{%s} 5} \times {\color[HTML]{%s} 2})" % (
            MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR, MY_RED_STR, MY_GREEN_STR, MY_BLUE_STR
        )
        core_equality = MathTex(core_eq_str, font_size=42, color=MY_DARK_BLUE, tex_template=color_support_template)
        # Position below the cube's projected area
        core_equality.move_to(DOWN * 1.5)

        # --- Conclusion Text (Fixed) ---
        conclusion_text = Text(
            "ä¸¤ç§ä¸åŒçš„è®¡ç®—é¡ºåºï¼Œå¾—åˆ°äº†å®Œå…¨ç›¸åŒçš„å‡ ä½•ä½“å’Œç»“æžœ (70)ã€‚\nè¿™ç›´è§‚åœ°è¯æ˜Žäº†ä¹˜æ³•ç»“åˆå¾‹ã€‚",
            font_size=32, color=MY_BLACK, line_spacing=0.8, should_center=True
        )
        conclusion_text.to_edge(DOWN, buff=0.8)

        # Add elements
        self.add(final_cube_display) # The 3D cube itself is not fixed
        fixed_elements = VGroup(formula_left_group, formula_right_group, arrow_left, arrow_right, core_equality, conclusion_text)
        self.add_fixed_in_frame_mobjects(fixed_elements)
        # Hide elements initially
        fixed_elements.set_opacity(0)


        # --- Animations ---
        voice_text_04 = "æœ€åŽæˆ‘ä»¬æ¥å¯¹æ¯”ä¸€ä¸‹ã€‚å·¦è¾¹æ˜¯å…ˆç®— 7 ä¹˜ 5ï¼Œå³è¾¹æ˜¯å…ˆç®— 5 ä¹˜ 2ã€‚è™½ç„¶è®¡ç®—è¿‡ç¨‹ä¸åŒï¼Œä½†æˆ‘ä»¬æœ€ç»ˆéƒ½å¾—åˆ°äº†ä¸­é—´è¿™ä¸ªå®Œå…¨ç›¸åŒçš„ã€ç”± 70 ä¸ªå°æ–¹å—ç»„æˆçš„ç°è‰²é•¿æ–¹ä½“ã€‚è¿™è¡¨æ˜Žï¼Œ(7 ä¹˜ä»¥ 5) å†ä¹˜ä»¥ 2ï¼Œç­‰äºŽ 7 ä¹˜ä»¥ (5 ä¹˜ä»¥ 2)ã€‚ä¸¤ç§ä¸åŒçš„è®¡ç®—é¡ºåºï¼Œå¾—åˆ°äº†å®Œå…¨ç›¸åŒçš„å‡ ä½•ä½“å’Œç»“æžœ 70ã€‚è¿™ç›´è§‚åœ°è¯æ˜Žäº†ä¹˜æ³•ç»“åˆå¾‹ã€‚"
        with custom_voiceover_tts(voice_text_04) as tracker:
            audio_duration = tracker.duration if tracker.audio_path else 0
            if tracker.audio_path and audio_duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else: print("Warning: Scene 4 TTS failed or has zero duration.")

            subtitle_voice = Text(voice_text_04, font_size=32, color=MY_BLACK, width=config.frame_width - 2, should_center=True)
            # Position subtitle above conclusion text
            subtitle_voice.next_to(conclusion_text, UP, buff=0.3)
            self.add_fixed_in_frame_mobjects(subtitle_voice)
            subtitle_voice.set_opacity(0) # Hide initially

            # Timings
            anim_cube_fadein = 1.5
            anim_rotate_start_delay = 0.5
            anim_rotate_duration = 8.0 # Slow rotation duration (used for wait calculation)
            anim_formulas_duration = 1.5
            anim_arrows_duration = 1.0
            anim_core_eq_duration = 1.0
            anim_conclusion_duration = 1.5
            fade_out_duration = 1.0

            # Fade in cube and subtitle
            self.play(
                FadeIn(final_cube_display),
                FadeIn(subtitle_voice, run_time=0.5), # Show subtitle early
                run_time=anim_cube_fadein
            )

            # Add rotation updater after a delay
            self.wait(anim_rotate_start_delay)
            # Define rotation speed (radians per second)
            rotation_speed = 0.2 # Radians per second
            final_cube_display.add_updater(lambda m, dt: m.rotate(rotation_speed * dt, axis=UP))

            # Show formulas, arrows, core equality, conclusion
            self.play(FadeIn(formula_left_group, shift=RIGHT*0.5), FadeIn(formula_right_group, shift=LEFT*0.5), run_time=anim_formulas_duration)
            self.play(Create(arrow_left), Create(arrow_right), run_time=anim_arrows_duration)
            self.play(Write(core_equality), run_time=anim_core_eq_duration) # Use Write for MathTex
            # Highlight equals sign
            self.play(Indicate(core_equality.get_part_by_tex("="), scale_factor=1.5, color=MY_RED))
            self.play(FadeIn(conclusion_text, shift=UP*0.3), run_time=anim_conclusion_duration)

            # Calculate wait time based on audio, considering rotation is ongoing
            # Time spent on main animations (excluding rotation start delay)
            main_anim_time = anim_cube_fadein + anim_formulas_duration + anim_arrows_duration + anim_core_eq_duration + 0.5 + anim_conclusion_duration # Added 0.5 for Indicate
            if audio_duration > 0:
                remaining_time = audio_duration - main_anim_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                # Wait for a reasonable time if no audio
                self.wait(max(0, anim_rotate_duration - main_anim_time)) # Wait roughly for rotation duration

            # Stop rotation before fading out
            # Check if updater exists before clearing
            if final_cube_display.get_updaters():
                 final_cube_display.clear_updaters()

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(2) # Hold final screen


# --- Main execution block ---
if __name__ == "__main__":
    config.pixel_height = 1080
    config.pixel_width = 1920
    config.frame_rate = 30
    config.output_file = "CombinedScene"
    config.disable_caching = True
    # Use placeholder for output path - IMPORTANT: Use raw string or double backslashes if needed on Windows
    config.media_dir = r"12" # Java will replace this placeholder

    scene = CombinedScene()
    scene.render()
    print(f"Scene rendering finished. Output in: {config.media_dir}")
```
