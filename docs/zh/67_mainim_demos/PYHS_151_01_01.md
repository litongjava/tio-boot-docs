# PYPH 151 homework 1 Quesiton 1

## Question

1. If two vectors have the same magnitude, do their components have to be the same?

No. The magnitude of a vector is equal to the Pythagorean sum of its components, i.e. \(v = \sqrt{v_x^2 + v_y^2}\). So, it is possible to have different components which sum up to the magnitude. For example, the vector \((3,4)\) has the same magnitude (viz. \(5\)) as the vector \((1,\sqrt{24})\).

## Explanation

## Sence Prompt

No, two vectors with the same magnitude do not necessarily have the same components.

Here's why:

- **Magnitude vs. Components:** The magnitude of a vector is its length, calculated using the Pythagorean theorem. The components of a vector describe its direction and "stretch" along coordinate axes.

- **Direction Matters:** Two vectors can have the same length but point in different directions. If they point in different directions, their components along a given coordinate system will be different.

**Example (2D):**

Consider two vectors with a magnitude of 5:

- **Vector A:** Components (3, 4). Magnitude = ‚àö(3¬≤ + 4¬≤) = ‚àö25 = 5
- **Vector B:** Components (5, 0). Magnitude = ‚àö(5¬≤ + 0¬≤) = ‚àö25 = 5

Both vectors have the same magnitude (5), but their components are different.

**In summary:** Equal magnitude only implies that the "lengths" of the vectors are the same. The components must be identical for the vectors to be equal (same magnitude _and_ direction).

# Code CN

```python
# -*- coding: utf-8 -*-
import os
import numpy as np
import requests
from contextlib import contextmanager
from manim import *
import hashlib
import manimpango # For font checking

# Import specific colors if needed (using SVGNAMES for broader compatibility)
from manim.utils.color.SVGNAMES import BLUE, GREEN, YELLOW, RED, WHITE, BLACK, GRAY, LIGHTGRAY, DARKGRAY

# Correct import for AudioFileClip
from moviepy import AudioFileClip

# --- Font Checking ---
DEFAULT_FONT = "Noto Sans CJK SC" # Example CJK font
available_fonts = manimpango.list_fonts()
final_font = None

if DEFAULT_FONT in available_fonts:
    print(f"Â≠ó‰Ωì '{DEFAULT_FONT}' Â∑≤ÊâæÂà∞„ÄÇ")
    final_font = DEFAULT_FONT
else:
    print(f"Ë≠¶Âëä: Â≠ó‰Ωì '{DEFAULT_FONT}' Êú™ÊâæÂà∞„ÄÇÊ≠£Âú®Â∞ùËØïÂ§áÁî®Â≠ó‰Ωì...")
    fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei", "Arial Unicode MS"]
    found_fallback = False
    for font in fallback_fonts:
        if font in available_fonts:
            print(f"Â∑≤ÂàáÊç¢Âà∞Â§áÁî®Â≠ó‰Ωì: '{font}'")
            final_font = font
            found_fallback = True
            break
    if not found_fallback:
        print(f"Ë≠¶Âëä: Êú™ÊâæÂà∞ÊåáÂÆöÁöÑ '{DEFAULT_FONT}' Êàñ‰ªª‰ΩïÂ§áÁî®‰∏≠ÊñáÂ≠ó‰Ωì„ÄÇÂ∞Ü‰ΩøÁî® Manim ÈªòËÆ§Â≠ó‰ΩìÔºå‰∏≠ÊñáÂèØËÉΩÊó†Ê≥ïÊ≠£Á°ÆÊòæÁ§∫„ÄÇ")
        # final_font remains None, Manim will use its default

# --- Custom Colors ---
MY_BLUE = "#2563EB"
MY_GREEN = "#10B981"
MY_YELLOW = "#F59E0B"
MY_RED = "#EF4444"
MY_PURPLE = "#8B5CF6"
MY_BACKGROUND = "#111827" # Dark background
MY_TEXT_COLOR = WHITE
MY_AXIS_COLOR = LIGHTGRAY
MY_GRID_COLOR = DARKGRAY

# --- TTS Caching Setup ---
CACHE_DIR = "tts_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

class CustomVoiceoverTracker:
    """Tracks audio path and duration for TTS."""
    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration

def get_cache_filename(text):
    """Generates a unique filename based on the text hash."""
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")

@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    """
    Fetches TTS audio, caches it, and provides path and duration.
    Usage: with custom_voiceover_tts("text") as tracker: ...
    """
    cache_file = get_cache_filename(text)
    audio_file = cache_file # Initialize audio_file

    if os.path.exists(cache_file):
        audio_file = cache_file
        print(f"Using cached TTS for: {text[:30]}...")
    else:
        print(f"Requesting TTS for: {text[:30]}...")
        try:
            input_text_encoded = requests.utils.quote(text)
            url = f"{base_url}?token={token}&input={input_text_encoded}"

            response = requests.get(url, stream=True, timeout=60)
            response.raise_for_status()

            with open(cache_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            audio_file = cache_file
            print("TTS downloaded and cached.")

        except requests.exceptions.RequestException as e:
            print(f"TTS API request failed: {e}")
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return

    if audio_file and os.path.exists(audio_file):
        try:
            # Use moviepy.editor.AudioFileClip
            clip = AudioFileClip(audio_file)
            duration = clip.duration
            clip.close()
            print(f"Audio duration: {duration:.2f}s")
            tracker = CustomVoiceoverTracker(audio_file, duration)
        except Exception as e:
            print(f"Error processing audio file {audio_file}: {e}")
            tracker = CustomVoiceoverTracker(None, 0)
    else:
        print(f"TTS audio file not found or not created: {audio_file}")
        tracker = CustomVoiceoverTracker(None, 0)

    try:
        yield tracker
    finally:
        pass

# --- Custom TeX Template for \color[HTML] ---
# Needed if using \color[HTML]{...} in MathTex/Tex
color_support_template = TexTemplate(
    preamble=r"""
\documentclass[preview]{standalone}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[HTML]{xcolor} %% <<< MUST INCLUDE THIS LINE for \color[HTML]
\usepackage{graphicx}
% Add other necessary packages here (e.g., ctex for Chinese in LaTeX)
% \usepackage{ctex} % Uncomment if mixing Chinese/Unicode in MathTex via \text{} (Risky!)
"""
)

# -----------------------------
# CombinedScene: Vector Magnitude vs Components
# -----------------------------
class CombinedScene(MovingCameraScene):
    """
    Explains why vectors with the same magnitude don't necessarily have the same components.
    """
    def setup(self):
        """Set default font if available."""
        Scene.setup(self)
        if final_font:
            Text.set_default(font=final_font)
            print(f"Default font set to: {final_font}")
        else:
            print("Using Manim's default font.")
        # Set default TexTemplate if needed globally
        # Tex.set_default(tex_template=color_support_template)
        # MathTex.set_default(tex_template=color_support_template)

    def construct(self):
        # Use a scene-specific time tracker if needed outside TTS timing
        self.scene_time_tracker = ValueTracker(0)

        # --- Play Scenes Sequentially ---
        self.play_scene_01() # Introduction
        self.clear_and_reset()

        self.play_scene_02() # Vector A Example
        self.clear_and_reset()

        self.play_scene_03() # Vector B Example
        self.clear_and_reset()

        self.play_scene_04() # Comparison and Conclusion
        self.clear_and_reset()

        # End of animation message
        final_message = Text("Âä®ÁîªÁªìÊùüÔºåÊÑüË∞¢ËßÇÁúãÔºÅ üòÑ", font_size=48, color=MY_TEXT_COLOR)
        bg_final = Rectangle(width=self.camera.frame_width, height=self.camera.frame_height, fill_color=MY_BACKGROUND, fill_opacity=1,
                             stroke_width=0).set_z_index(-10)
        self.add(bg_final)
        self.play(FadeIn(final_message))
        self.wait(2)

    def get_scene_number(self, number_str):
        """Creates and positions the scene number."""
        scene_num = Text(number_str, font_size=24, color=LIGHTGRAY)
        scene_num.to_corner(UR, buff=0.3)
        scene_num.set_z_index(10) # Ensure it's above background
        return scene_num

    def clear_and_reset(self):
        """Clears all mobjects and resets the camera."""
        # Clear updaters from all mobjects
        all_mobs_to_clear = list(self.mobjects)
        # Include fixed_in_frame_mobjects if in ThreeDScene context (not needed for MovingCameraScene unless manually added)
        # if hasattr(self.camera, 'fixed_in_frame_mobjects'):
        #     all_mobs_to_clear += list(self.camera.fixed_in_frame_mobjects)

        for mob in all_mobs_to_clear:
            # Check if the updater list is not empty before clearing
            if mob is not None and hasattr(mob, 'get_updaters') and mob.get_updaters():
                 mob.clear_updaters()

        # Use Group for potentially mixed object types
        valid_mobjects = [m for m in self.mobjects if m is not None]
        all_mobjects_group = Group(*valid_mobjects)

        if all_mobjects_group:
            self.play(FadeOut(all_mobjects_group, shift=DOWN * 0.5), run_time=0.5)

        # Clear the scene's mobject list
        self.clear()
        # If fixed_in_frame_mobjects were used, clear them too
        # if hasattr(self.camera, 'fixed_in_frame_mobjects'):
        #     self.camera.fixed_in_frame_mobjects.clear()

        # Reset camera position and scale for MovingCameraScene
        self.camera.frame.move_to(ORIGIN)
        # Ensure frame dimensions match configuration
        self.camera.frame.set(width=config.frame_width, height=config.frame_height)
        # Reset zoom/scale if needed (set width is usually sufficient)
        # self.camera.frame.scale(1 / self.camera.frame.get_width() * config.frame_width) # More robust reset if scale was used

        # Reset the custom time tracker
        self.scene_time_tracker.set_value(0)
        self.wait(0.1) # Short pause after reset

    # --- Scene 1: Introduction ---
    def play_scene_01(self):
        """Scene 1: Introduce the question."""
        self.scene_time_tracker.set_value(0)

        # Background
        bg1 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg1)

        # Scene Number
        scene_num_01 = self.get_scene_number("01")
        self.add(scene_num_01)

        # Title
        title = Text(
            "ÁñëÈóÆ ü§îÔºöÊ®°ÈïøÁõ∏ÂêåÁöÑÂêëÈáèÔºåÂàÜÈáè‰∏ÄÂÆöÁõ∏ÂêåÂêóÔºü",
            font_size=48,
            color=MY_TEXT_COLOR,
            # Use width for auto line breaking if needed
            width=config.frame_width - 2,
            should_center=True
        )
        title.move_to(ORIGIN)

        # --- TTS Integration ---
        voice_text_01 = "Â§ßÂÆ∂Â•ΩÔºÅ‰ªäÂ§©Êàë‰ª¨Êù•Êé¢ËÆ®‰∏Ä‰∏™ÂÖ≥‰∫éÂêëÈáèÁöÑÈóÆÈ¢òÔºöÊ®°ÈïøÁõ∏ÂêåÁöÑ‰∏§‰∏™ÂêëÈáèÔºåÂÆÉ‰ª¨ÁöÑÂùêÊ†áÂàÜÈáè‰∏ÄÂÆöÁõ∏ÂêåÂêóÔºü ü§î"
        with custom_voiceover_tts(voice_text_01) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 1 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_01, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animation
            anim_runtime = 2.0
            fade_out_duration = 1.0
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Write(title), # Use Write for Text if it looks better, else FadeIn
                    lag_ratio=0.0
                ),
                run_time=anim_runtime
            )

            # Calculate wait time
            if tracker.duration > 0:
                elapsed_time = anim_runtime
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.5) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 2: Vector A Example ---
    def play_scene_02(self):
        """Scene 2: Show Vector A, its components, and magnitude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid
        bg2 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg2)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, # Hide grid's own axes
            x_axis_config={"stroke_width": 0},
            y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_02 = self.get_scene_number("02")
        self.add(scene_num_02)

        # Axes
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True, # Show tips
        ).add_coordinates() # Add coordinate numbers
        axes.move_to(ORIGIN)
        self.axes = axes # Store axes as instance variable if needed later

        # Vector A
        vec_A_coords = np.array([3, 4, 0])
        vec_A = Vector(vec_A_coords, color=MY_BLUE, tip_shape=ArrowTriangleFilledTip)
        vec_A_label = MathTex(r"\vec{A} = (3, 4)", color=MY_BLUE, font_size=36)
        vec_A_label.next_to(vec_A.get_end(), UR, buff=0.2)

        # Magnitude Calculation for A
        # Use rf string for raw formatting, allows backslashes
        mag_A_calc = MathTex(
            r"|\vec{A}| = \sqrt{3^2 + 4^2}", r" = \sqrt{9 + 16}", r" = \sqrt{25}", r" = 5",
            font_size=40, color=MY_TEXT_COLOR
        )
        # Arrange parts horizontally
        mag_A_calc.arrange(RIGHT, buff=0.2)
        mag_A_calc.to_edge(UP, buff=0.5) # Position calculation at the top

        # --- TTS Integration ---
        voice_text_02 = "Êàë‰ª¨Êù•ÁúãÁ¨¨‰∏Ä‰∏™‰æãÂ≠ê„ÄÇÂÅáËÆæÂêëÈáè A ÁöÑÂàÜÈáèÊòØ (3, 4)„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁîªÂá∫Ëøô‰∏™ÂêëÈáè„ÄÇÁé∞Âú®Êàë‰ª¨Êù•ËÆ°ÁÆóÂÆÉÁöÑÊ®°ÈïøÔºåÊ†πÊçÆÂãæËÇ°ÂÆöÁêÜÔºåÊ®°ÈïøÁ≠â‰∫éÊ†πÂè∑‰∏ã 3 ÁöÑÂπ≥ÊñπÂä† 4 ÁöÑÂπ≥ÊñπÔºå‰πüÂ∞±ÊòØÊ†πÂè∑ 25ÔºåÁ≠â‰∫é 5„ÄÇ"
        with custom_voiceover_tts(voice_text_02) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 2 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_02, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Create(axes),
                    lag_ratio=0.0
                ),
                run_time=1.5
            )
            self.play(
                Create(vec_A), # Use Create for Vector
                Write(vec_A_label),
                run_time=1.5
            )
            # Show calculation step-by-step
            self.play(Write(mag_A_calc[0]), run_time=1.5) # sqrt(3^2 + 4^2)
            self.play(Write(mag_A_calc[1]), run_time=1.0) # = sqrt(9+16)
            self.play(Write(mag_A_calc[2]), run_time=1.0) # = sqrt(25)
            self.play(Write(mag_A_calc[3]), run_time=1.0) # = 5
            # Highlight the result
            self.play(Indicate(mag_A_calc[3], color=MY_YELLOW, scale_factor=1.2), run_time=1.0)

            # Calculate wait time
            anim_time = 1.5 + 1.5 + 1.5 + 1.0 + 1.0 + 1.0 + 1.0 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 3: Vector B Example ---
    def play_scene_03(self):
        """Scene 3: Show Vector B, its components, and magnitude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid (same as Scene 2)
        bg3 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg3)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, x_axis_config={"stroke_width": 0}, y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_03 = self.get_scene_number("03")
        self.add(scene_num_03)

        # Axes (same as Scene 2)
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True,
        ).add_coordinates()
        axes.move_to(ORIGIN)
        self.add(axes) # Add axes directly as they are reused visually
        self.axes = axes # Update instance variable if needed

        # Vector B
        vec_B_coords = np.array([5, 0, 0])
        vec_B = Vector(vec_B_coords, color=MY_GREEN, tip_shape=ArrowTriangleFilledTip)
        vec_B_label = MathTex(r"\vec{B} = (5, 0)", color=MY_GREEN, font_size=36)
        # Position label carefully for vector on axis
        vec_B_label.next_to(vec_B.get_end(), DOWN, buff=0.2).shift(LEFT*0.5)

        # Magnitude Calculation for B
        mag_B_calc = MathTex(
            r"|\vec{B}| = \sqrt{5^2 + 0^2}", r" = \sqrt{25 + 0}", r" = \sqrt{25}", r" = 5",
            font_size=40, color=MY_TEXT_COLOR
        )
        mag_B_calc.arrange(RIGHT, buff=0.2)
        mag_B_calc.to_edge(UP, buff=0.5)

        # --- TTS Integration ---
        voice_text_03 = "Áé∞Âú®ÁúãÁ¨¨‰∫å‰∏™‰æãÂ≠ê„ÄÇÂÅáËÆæÂêëÈáè B ÁöÑÂàÜÈáèÊòØ (5, 0)„ÄÇÊàë‰ª¨ÁîªÂá∫Ëøô‰∏™ÂêëÈáèÔºåÂÆÉÂÆåÂÖ®ËêΩÂú® x ËΩ¥‰∏ä„ÄÇËÆ°ÁÆóÂÆÉÁöÑÊ®°ÈïøÔºöÊ†πÂè∑‰∏ã 5 ÁöÑÂπ≥ÊñπÂä† 0 ÁöÑÂπ≥ÊñπÔºåËøòÊòØÊ†πÂè∑ 25Ôºå‰πüÁ≠â‰∫é 5„ÄÇ"
        with custom_voiceover_tts(voice_text_03) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 3 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_03, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(FadeIn(subtitle_voice, run_time=0.5)) # Subtitle first
            self.play(
                Create(vec_B),
                Write(vec_B_label),
                run_time=1.5
            )
            # Show calculation step-by-step
            self.play(Write(mag_B_calc[0]), run_time=1.5) # sqrt(5^2 + 0^2)
            self.play(Write(mag_B_calc[1]), run_time=1.0) # = sqrt(25+0)
            self.play(Write(mag_B_calc[2]), run_time=1.0) # = sqrt(25)
            self.play(Write(mag_B_calc[3]), run_time=1.0) # = 5
            # Highlight the result
            self.play(Indicate(mag_B_calc[3], color=MY_YELLOW, scale_factor=1.2), run_time=1.0)

            # Calculate wait time
            anim_time = 0.5 + 1.5 + 1.5 + 1.0 + 1.0 + 1.0 + 1.0 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 4: Comparison and Conclusion ---
    def play_scene_04(self):
        """Scene 4: Show both vectors, compare, and conclude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid
        bg4 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg4)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, x_axis_config={"stroke_width": 0}, y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_04 = self.get_scene_number("04")
        self.add(scene_num_04)

        # Axes
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True,
        ).add_coordinates()
        axes.move_to(ORIGIN)
        self.add(axes)
        self.axes = axes

        # Vector A and B together
        vec_A_coords = np.array([3, 4, 0])
        vec_A = Vector(vec_A_coords, color=MY_BLUE, tip_shape=ArrowTriangleFilledTip)
        vec_A_label = MathTex(r"\vec{A} = (3, 4)", color=MY_BLUE, font_size=36)
        vec_A_label.next_to(vec_A.get_end(), UR, buff=0.2)

        vec_B_coords = np.array([5, 0, 0])
        vec_B = Vector(vec_B_coords, color=MY_GREEN, tip_shape=ArrowTriangleFilledTip)
        vec_B_label = MathTex(r"\vec{B} = (5, 0)", color=MY_GREEN, font_size=36)
        vec_B_label.next_to(vec_B.get_end(), DOWN, buff=0.2).shift(LEFT*0.5)

        # Comparison Text
        mag_text = Text("Ê®°ÈïøÁõ∏Âêå: |A| = |B| = 5", font_size=36, color=MY_YELLOW)
        comp_text = Text("ÂàÜÈáè‰∏çÂêå: (3, 4) ‚â† (5, 0)", font_size=36, color=MY_RED)
        dir_text = Text("ÊñπÂêë‰∏çÂêå!", font_size=36, color=MY_TEXT_COLOR)

        comparison_group = VGroup(mag_text, comp_text, dir_text).arrange(DOWN, buff=0.3, aligned_edge=LEFT)
        comparison_group.to_corner(UL, buff=0.5) # Position top-left

        # Conclusion Text
        conclusion = Text(
            "ÁªìËÆ∫ÔºöÊ®°ÈïøÁõ∏Âêå ‚â† ÂàÜÈáèÁõ∏Âêå\n(ËøòÈúÄË¶ÅÊñπÂêëÁõ∏ÂêåÔºÅ)",
            font_size=40,
            color=MY_TEXT_COLOR,
            line_spacing=0.8, # Adjust line spacing if needed
            should_center=True,
            width = config.frame_width * 0.5 # Limit width
        )
        conclusion.to_edge(UP, buff=0.5)

        # --- TTS Integration ---
        voice_text_04 = "Áé∞Âú®Êàë‰ª¨Êää‰∏§‰∏™ÂêëÈáèÊîæÂú®‰∏ÄËµ∑Áúã„ÄÇÂêëÈáè A ÊòØ (3, 4)ÔºåÂêëÈáè B ÊòØ (5, 0)„ÄÇÂÆÉ‰ª¨ÁöÑÊ®°ÈïøÈÉΩÊòØ 5Ôºå‰ΩÜÊòØÂÆÉ‰ª¨ÁöÑÂàÜÈáèÊòæÁÑ∂‰∏çÂêåÔºåÊåáÂêëÁöÑÊñπÂêë‰πü‰∏çÂêå„ÄÇÊâÄ‰ª•ÔºåÊàë‰ª¨ÁöÑÁªìËÆ∫ÊòØÔºö‰ªÖ‰ªÖÊ®°ÈïøÁõ∏ÂêåÔºåÂπ∂‰∏çËÉΩ‰øùËØÅÂêëÈáèÁöÑÂàÜÈáè‰πüÁõ∏Âêå„ÄÇÂêëÈáèÁõ∏Á≠âÊÑèÂë≥ÁùÄÊ®°ÈïøÂíåÊñπÂêëÈÉΩÂøÖÈ°ªÁõ∏ÂêåÔºÅ"
        with custom_voiceover_tts(voice_text_04) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 4 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_04, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Create(vec_A), Write(vec_A_label),
                    Create(vec_B), Write(vec_B_label),
                    lag_ratio=0.1 # Stagger the appearance slightly
                ),
                run_time=2.5
            )
            # Show comparison points
            self.play(FadeIn(mag_text, shift=RIGHT*0.2), run_time=1.0)
            self.play(FadeIn(comp_text, shift=RIGHT*0.2), run_time=1.0)
            self.play(FadeIn(dir_text, shift=RIGHT*0.2), run_time=1.0)
            self.wait(0.5)
            # Show conclusion
            self.play(FadeIn(conclusion, scale=0.8), run_time=1.5) # Scale in for emphasis

            # Calculate wait time
            anim_time = 2.5 + 1.0 + 1.0 + 1.0 + 0.5 + 1.5 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.5) # Wait if no audio

            # Keep conclusion, fade subtitle
            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)
            # Fade out comparison details, keep vectors and conclusion
            self.play(FadeOut(comparison_group), run_time=0.5)

        self.wait(1.5) # Hold final comparison screen


# --- Main execution block ---
if __name__ == "__main__":
    # Basic configuration
    config.pixel_height = 1080
    config.pixel_width = 1920
    config.frame_rate = 30
    config.output_file = "CombinedScene" # Output filename
    config.disable_caching = True # Disable caching

    # Set output directory using placeholder
    # IMPORTANT: Ensure this placeholder is correctly replaced by your Java process
    config.media_dir = "./#(output_path)" # Placeholder for output directory

    # Create and render the scene
    scene = CombinedScene()
    scene.render()

    print(f"Scene rendering finished. Output should be in: {config.media_dir}")
    # Check if the file exists (optional verification)
    output_file_path = os.path.join(config.media_dir, f"{config.output_file}.mp4")
    if os.path.exists(output_file_path):
        print(f"Output file found: {output_file_path}")
    else:
        print(f"Warning: Output file not found at expected location: {output_file_path}")
```

## code en

```python
# -*- coding: utf-8 -*-
import os
import numpy as np
import requests
from contextlib import contextmanager
from manim import *
import hashlib
import manimpango # For font checking

# Import specific colors if needed (using SVGNAMES for broader compatibility)
from manim.utils.color.SVGNAMES import BLUE, GREEN, YELLOW, RED, WHITE, BLACK, GRAY, LIGHTGRAY, DARKGRAY

# Correct import for AudioFileClip
from moviepy import AudioFileClip # Corrected import path

# --- Font Checking ---
DEFAULT_FONT = "Noto Sans CJK SC" # Example CJK font
available_fonts = manimpango.list_fonts()
final_font = None

if DEFAULT_FONT in available_fonts:
    print(f"Font '{DEFAULT_FONT}' found.") # Changed: Â≠ó‰Ωì '{DEFAULT_FONT}' Â∑≤ÊâæÂà∞„ÄÇ
    final_font = DEFAULT_FONT
else:
    print(f"Warning: Font '{DEFAULT_FONT}' not found. Trying fallback fonts...") # Changed: Ë≠¶Âëä: Â≠ó‰Ωì '{DEFAULT_FONT}' Êú™ÊâæÂà∞„ÄÇÊ≠£Âú®Â∞ùËØïÂ§áÁî®Â≠ó‰Ωì...
    fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei", "Arial Unicode MS"]
    found_fallback = False
    for font in fallback_fonts:
        if font in available_fonts:
            print(f"Switched to fallback font: '{font}'") # Changed: Â∑≤ÂàáÊç¢Âà∞Â§áÁî®Â≠ó‰Ωì: '{font}'
            final_font = font
            found_fallback = True
            break
    if not found_fallback:
        print(f"Warning: Neither the specified '{DEFAULT_FONT}' nor any fallback CJK fonts were found. Using Manim's default font. Chinese characters might not display correctly.") # Changed: Ë≠¶Âëä: Êú™ÊâæÂà∞ÊåáÂÆöÁöÑ '{DEFAULT_FONT}' Êàñ‰ªª‰ΩïÂ§áÁî®‰∏≠ÊñáÂ≠ó‰Ωì„ÄÇÂ∞Ü‰ΩøÁî® Manim ÈªòËÆ§Â≠ó‰ΩìÔºå‰∏≠ÊñáÂèØËÉΩÊó†Ê≥ïÊ≠£Á°ÆÊòæÁ§∫„ÄÇ
        # final_font remains None, Manim will use its default

# --- Custom Colors ---
MY_BLUE = "#2563EB"
MY_GREEN = "#10B981"
MY_YELLOW = "#F59E0B"
MY_RED = "#EF4444"
MY_PURPLE = "#8B5CF6"
MY_BACKGROUND = "#111827" # Dark background
MY_TEXT_COLOR = WHITE
MY_AXIS_COLOR = LIGHTGRAY
MY_GRID_COLOR = DARKGRAY

# --- TTS Caching Setup ---
CACHE_DIR = "tts_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

class CustomVoiceoverTracker:
    """Tracks audio path and duration for TTS."""
    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration

def get_cache_filename(text):
    """Generates a unique filename based on the text hash."""
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")

@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    """
    Fetches TTS audio, caches it, and provides path and duration.
    Usage: with custom_voiceover_tts("text") as tracker: ...
    """
    cache_file = get_cache_filename(text)
    audio_file = cache_file # Initialize audio_file

    if os.path.exists(cache_file):
        audio_file = cache_file
        print(f"Using cached TTS for: {text[:30]}...")
    else:
        print(f"Requesting TTS for: {text[:30]}...")
        try:
            input_text_encoded = requests.utils.quote(text)
            url = f"{base_url}?token={token}&input={input_text_encoded}"

            response = requests.get(url, stream=True, timeout=60)
            response.raise_for_status()

            with open(cache_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            audio_file = cache_file
            print("TTS downloaded and cached.")

        except requests.exceptions.RequestException as e:
            print(f"TTS API request failed: {e}")
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return

    if audio_file and os.path.exists(audio_file):
        try:
            # Use moviepy.editor.AudioFileClip
            clip = AudioFileClip(audio_file)
            duration = clip.duration
            clip.close()
            print(f"Audio duration: {duration:.2f}s")
            tracker = CustomVoiceoverTracker(audio_file, duration)
        except Exception as e:
            print(f"Error processing audio file {audio_file}: {e}")
            tracker = CustomVoiceoverTracker(None, 0)
    else:
        print(f"TTS audio file not found or not created: {audio_file}")
        tracker = CustomVoiceoverTracker(None, 0)

    try:
        yield tracker
    finally:
        pass

# --- Custom TeX Template for \color[HTML] ---
# Needed if using \color[HTML]{...} in MathTex/Tex
color_support_template = TexTemplate(
    preamble=r"""
\documentclass[preview]{standalone}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[HTML]{xcolor} %% <<< MUST INCLUDE THIS LINE for \color[HTML]
\usepackage{graphicx}
% Add other necessary packages here (e.g., ctex for Chinese in LaTeX)
% \usepackage{ctex} % Uncomment if mixing Chinese/Unicode in MathTex via \text{} (Risky!)
"""
)

# -----------------------------
# CombinedScene: Vector Magnitude vs Components
# -----------------------------
class CombinedScene(MovingCameraScene):
    """
    Explains why vectors with the same magnitude don't necessarily have the same components.
    """
    def setup(self):
        """Set default font if available."""
        Scene.setup(self)
        if final_font:
            Text.set_default(font=final_font)
            print(f"Default font set to: {final_font}")
        else:
            print("Using Manim's default font.")
        # Set default TexTemplate if needed globally
        # Tex.set_default(tex_template=color_support_template)
        # MathTex.set_default(tex_template=color_support_template)

    def construct(self):
        # Use a scene-specific time tracker if needed outside TTS timing
        self.scene_time_tracker = ValueTracker(0)

        # --- Play Scenes Sequentially ---
        self.play_scene_01() # Introduction
        self.clear_and_reset()

        self.play_scene_02() # Vector A Example
        self.clear_and_reset()

        self.play_scene_03() # Vector B Example
        self.clear_and_reset()

        self.play_scene_04() # Comparison and Conclusion
        self.clear_and_reset()

        # End of animation message
        final_message = Text("Animation finished, thanks for watching! üòÑ", font_size=48, color=MY_TEXT_COLOR) # Changed: Âä®ÁîªÁªìÊùüÔºåÊÑüË∞¢ËßÇÁúãÔºÅ üòÑ
        bg_final = Rectangle(width=self.camera.frame_width, height=self.camera.frame_height, fill_color=MY_BACKGROUND, fill_opacity=1,
                             stroke_width=0).set_z_index(-10)
        self.add(bg_final)
        self.play(FadeIn(final_message))
        self.wait(2)

    def get_scene_number(self, number_str):
        """Creates and positions the scene number."""
        scene_num = Text(number_str, font_size=24, color=LIGHTGRAY)
        scene_num.to_corner(UR, buff=0.3)
        scene_num.set_z_index(10) # Ensure it's above background
        return scene_num

    def clear_and_reset(self):
        """Clears all mobjects and resets the camera."""
        # Clear updaters from all mobjects
        all_mobs_to_clear = list(self.mobjects)
        # Include fixed_in_frame_mobjects if in ThreeDScene context (not needed for MovingCameraScene unless manually added)
        # if hasattr(self.camera, 'fixed_in_frame_mobjects'):
        #     all_mobs_to_clear += list(self.camera.fixed_in_frame_mobjects)

        for mob in all_mobs_to_clear:
            # Check if the updater list is not empty before clearing
            if mob is not None and hasattr(mob, 'get_updaters') and mob.get_updaters():
                 mob.clear_updaters()

        # Use Group for potentially mixed object types
        valid_mobjects = [m for m in self.mobjects if m is not None]
        all_mobjects_group = Group(*valid_mobjects)

        if all_mobjects_group:
            self.play(FadeOut(all_mobjects_group, shift=DOWN * 0.5), run_time=0.5)

        # Clear the scene's mobject list
        self.clear()
        # If fixed_in_frame_mobjects were used, clear them too
        # if hasattr(self.camera, 'fixed_in_frame_mobjects'):
        #     self.camera.fixed_in_frame_mobjects.clear()

        # Reset camera position and scale for MovingCameraScene
        self.camera.frame.move_to(ORIGIN)
        # Ensure frame dimensions match configuration
        self.camera.frame.set(width=config.frame_width, height=config.frame_height)
        # Reset zoom/scale if needed (set width is usually sufficient)
        # self.camera.frame.scale(1 / self.camera.frame.get_width() * config.frame_width) # More robust reset if scale was used

        # Reset the custom time tracker
        self.scene_time_tracker.set_value(0)
        self.wait(0.1) # Short pause after reset

    # --- Scene 1: Introduction ---
    def play_scene_01(self):
        """Scene 1: Introduce the question."""
        self.scene_time_tracker.set_value(0)

        # Background
        bg1 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg1)

        # Scene Number
        scene_num_01 = self.get_scene_number("01")
        self.add(scene_num_01)

        # Title
        title = Text(
            "Question ü§î: Do vectors with the same magnitude always have the same components?", # Changed: ÁñëÈóÆ ü§îÔºöÊ®°ÈïøÁõ∏ÂêåÁöÑÂêëÈáèÔºåÂàÜÈáè‰∏ÄÂÆöÁõ∏ÂêåÂêóÔºü
            font_size=48,
            color=MY_TEXT_COLOR,
            # Use width for auto line breaking if needed
            width=config.frame_width - 2,
            should_center=True
        )
        title.move_to(ORIGIN)

        # --- TTS Integration ---
        voice_text_01 = "Hello everyone! Today we'll explore a question about vectors: If two vectors have the same magnitude, do they necessarily have the same coordinate components? ü§î" # Changed: Â§ßÂÆ∂Â•ΩÔºÅ‰ªäÂ§©Êàë‰ª¨Êù•Êé¢ËÆ®‰∏Ä‰∏™ÂÖ≥‰∫éÂêëÈáèÁöÑÈóÆÈ¢òÔºöÊ®°ÈïøÁõ∏ÂêåÁöÑ‰∏§‰∏™ÂêëÈáèÔºåÂÆÉ‰ª¨ÁöÑÂùêÊ†áÂàÜÈáè‰∏ÄÂÆöÁõ∏ÂêåÂêóÔºü ü§î
        with custom_voiceover_tts(voice_text_01) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 1 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_01, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animation
            anim_runtime = 2.0
            fade_out_duration = 1.0
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Write(title), # Use Write for Text if it looks better, else FadeIn
                    lag_ratio=0.0
                ),
                run_time=anim_runtime
            )

            # Calculate wait time
            if tracker.duration > 0:
                elapsed_time = anim_runtime
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.5) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 2: Vector A Example ---
    def play_scene_02(self):
        """Scene 2: Show Vector A, its components, and magnitude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid
        bg2 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg2)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, # Hide grid's own axes
            x_axis_config={"stroke_width": 0},
            y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_02 = self.get_scene_number("02")
        self.add(scene_num_02)

        # Axes
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True, # Show tips
        ).add_coordinates() # Add coordinate numbers
        axes.move_to(ORIGIN)
        self.axes = axes # Store axes as instance variable if needed later

        # Vector A
        vec_A_coords = np.array([3, 4, 0])
        vec_A = Vector(vec_A_coords, color=MY_BLUE, tip_shape=ArrowTriangleFilledTip)
        vec_A_label = MathTex(r"\vec{A} = (3, 4)", color=MY_BLUE, font_size=36)
        vec_A_label.next_to(vec_A.get_end(), UR, buff=0.2)

        # Magnitude Calculation for A
        # Use rf string for raw formatting, allows backslashes
        mag_A_calc = MathTex(
            r"|\vec{A}| = \sqrt{3^2 + 4^2}", r" = \sqrt{9 + 16}", r" = \sqrt{25}", r" = 5",
            font_size=40, color=MY_TEXT_COLOR
        )
        # Arrange parts horizontally
        mag_A_calc.arrange(RIGHT, buff=0.2)
        mag_A_calc.to_edge(UP, buff=0.5) # Position calculation at the top

        # --- TTS Integration ---
        voice_text_02 = "Let's look at the first example. Suppose vector A has components (3, 4). We can draw this vector. Now let's calculate its magnitude. According to the Pythagorean theorem, the magnitude is the square root of 3 squared plus 4 squared, which is the square root of 25, equaling 5." # Changed: Êàë‰ª¨Êù•ÁúãÁ¨¨‰∏Ä‰∏™‰æãÂ≠ê„ÄÇÂÅáËÆæÂêëÈáè A ÁöÑÂàÜÈáèÊòØ (3, 4)„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁîªÂá∫Ëøô‰∏™ÂêëÈáè„ÄÇÁé∞Âú®Êàë‰ª¨Êù•ËÆ°ÁÆóÂÆÉÁöÑÊ®°ÈïøÔºåÊ†πÊçÆÂãæËÇ°ÂÆöÁêÜÔºåÊ®°ÈïøÁ≠â‰∫éÊ†πÂè∑‰∏ã 3 ÁöÑÂπ≥ÊñπÂä† 4 ÁöÑÂπ≥ÊñπÔºå‰πüÂ∞±ÊòØÊ†πÂè∑ 25ÔºåÁ≠â‰∫é 5„ÄÇ
        with custom_voiceover_tts(voice_text_02) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 2 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_02, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Create(axes),
                    lag_ratio=0.0
                ),
                run_time=1.5
            )
            self.play(
                Create(vec_A), # Use Create for Vector
                Write(vec_A_label),
                run_time=1.5
            )
            # Show calculation step-by-step
            self.play(Write(mag_A_calc[0]), run_time=1.5) # sqrt(3^2 + 4^2)
            self.play(Write(mag_A_calc[1]), run_time=1.0) # = sqrt(9+16)
            self.play(Write(mag_A_calc[2]), run_time=1.0) # = sqrt(25)
            self.play(Write(mag_A_calc[3]), run_time=1.0) # = 5
            # Highlight the result
            self.play(Indicate(mag_A_calc[3], color=MY_YELLOW, scale_factor=1.2), run_time=1.0)

            # Calculate wait time
            anim_time = 1.5 + 1.5 + 1.5 + 1.0 + 1.0 + 1.0 + 1.0 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 3: Vector B Example ---
    def play_scene_03(self):
        """Scene 3: Show Vector B, its components, and magnitude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid (same as Scene 2)
        bg3 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg3)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, x_axis_config={"stroke_width": 0}, y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_03 = self.get_scene_number("03")
        self.add(scene_num_03)

        # Axes (same as Scene 2)
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True,
        ).add_coordinates()
        axes.move_to(ORIGIN)
        self.add(axes) # Add axes directly as they are reused visually
        self.axes = axes # Update instance variable if needed

        # Vector B
        vec_B_coords = np.array([5, 0, 0])
        vec_B = Vector(vec_B_coords, color=MY_GREEN, tip_shape=ArrowTriangleFilledTip)
        vec_B_label = MathTex(r"\vec{B} = (5, 0)", color=MY_GREEN, font_size=36)
        # Position label carefully for vector on axis
        vec_B_label.next_to(vec_B.get_end(), DOWN, buff=0.2).shift(LEFT*0.5)

        # Magnitude Calculation for B
        mag_B_calc = MathTex(
            r"|\vec{B}| = \sqrt{5^2 + 0^2}", r" = \sqrt{25 + 0}", r" = \sqrt{25}", r" = 5",
            font_size=40, color=MY_TEXT_COLOR
        )
        mag_B_calc.arrange(RIGHT, buff=0.2)
        mag_B_calc.to_edge(UP, buff=0.5)

        # --- TTS Integration ---
        voice_text_03 = "Now for the second example. Suppose vector B has components (5, 0). Let's draw this vector; it lies entirely on the x-axis. Calculating its magnitude: the square root of 5 squared plus 0 squared, which is still the square root of 25, also equals 5." # Changed: Áé∞Âú®ÁúãÁ¨¨‰∫å‰∏™‰æãÂ≠ê„ÄÇÂÅáËÆæÂêëÈáè B ÁöÑÂàÜÈáèÊòØ (5, 0)„ÄÇÊàë‰ª¨ÁîªÂá∫Ëøô‰∏™ÂêëÈáèÔºåÂÆÉÂÆåÂÖ®ËêΩÂú® x ËΩ¥‰∏ä„ÄÇËÆ°ÁÆóÂÆÉÁöÑÊ®°ÈïøÔºöÊ†πÂè∑‰∏ã 5 ÁöÑÂπ≥ÊñπÂä† 0 ÁöÑÂπ≥ÊñπÔºåËøòÊòØÊ†πÂè∑ 25Ôºå‰πüÁ≠â‰∫é 5„ÄÇ
        with custom_voiceover_tts(voice_text_03) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 3 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_03, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(FadeIn(subtitle_voice, run_time=0.5)) # Subtitle first
            self.play(
                Create(vec_B),
                Write(vec_B_label),
                run_time=1.5
            )
            # Show calculation step-by-step
            self.play(Write(mag_B_calc[0]), run_time=1.5) # sqrt(5^2 + 0^2)
            self.play(Write(mag_B_calc[1]), run_time=1.0) # = sqrt(25+0)
            self.play(Write(mag_B_calc[2]), run_time=1.0) # = sqrt(25)
            self.play(Write(mag_B_calc[3]), run_time=1.0) # = 5
            # Highlight the result
            self.play(Indicate(mag_B_calc[3], color=MY_YELLOW, scale_factor=1.2), run_time=1.0)

            # Calculate wait time
            anim_time = 0.5 + 1.5 + 1.5 + 1.0 + 1.0 + 1.0 + 1.0 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0) # Wait if no audio

            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        self.wait(0.5)

    # --- Scene 4: Comparison and Conclusion ---
    def play_scene_04(self):
        """Scene 4: Show both vectors, compare, and conclude."""
        self.scene_time_tracker.set_value(0)

        # Background & Grid
        bg4 = Rectangle(
            width=self.camera.frame_width, height=self.camera.frame_height,
            fill_color=MY_BACKGROUND, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg4)
        grid = NumberPlane(
            x_range=[-8, 8, 1], y_range=[-5, 5, 1],
            x_length=self.camera.frame_width, y_length=self.camera.frame_height,
            background_line_style={"stroke_color": MY_GRID_COLOR, "stroke_width": 1, "stroke_opacity": 0.4},
            axis_config={"stroke_width": 0}, x_axis_config={"stroke_width": 0}, y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)
        self.add(grid)

        # Scene Number
        scene_num_04 = self.get_scene_number("04")
        self.add(scene_num_04)

        # Axes
        axes = Axes(
            x_range=[-1, 6, 1], y_range=[-1, 5, 1],
            x_length=7, y_length=6,
            axis_config={"color": MY_AXIS_COLOR, "include_numbers": True, "tip_shape": StealthTip},
            x_axis_config={"color": MY_AXIS_COLOR},
            y_axis_config={"color": MY_AXIS_COLOR},
            tips=True,
        ).add_coordinates()
        axes.move_to(ORIGIN)
        self.add(axes)
        self.axes = axes

        # Vector A and B together
        vec_A_coords = np.array([3, 4, 0])
        vec_A = Vector(vec_A_coords, color=MY_BLUE, tip_shape=ArrowTriangleFilledTip)
        vec_A_label = MathTex(r"\vec{A} = (3, 4)", color=MY_BLUE, font_size=36)
        vec_A_label.next_to(vec_A.get_end(), UR, buff=0.2)

        vec_B_coords = np.array([5, 0, 0])
        vec_B = Vector(vec_B_coords, color=MY_GREEN, tip_shape=ArrowTriangleFilledTip)
        vec_B_label = MathTex(r"\vec{B} = (5, 0)", color=MY_GREEN, font_size=36)
        vec_B_label.next_to(vec_B.get_end(), DOWN, buff=0.2).shift(LEFT*0.5)

        # Comparison Text
        mag_text = Text("Same Magnitude: |A| = |B| = 5", font_size=36, color=MY_YELLOW) # Changed: Ê®°ÈïøÁõ∏Âêå: |A| = |B| = 5
        comp_text = Text("Different Components: (3, 4) ‚â† (5, 0)", font_size=36, color=MY_RED) # Changed: ÂàÜÈáè‰∏çÂêå: (3, 4) ‚â† (5, 0)
        dir_text = Text("Different Directions!", font_size=36, color=MY_TEXT_COLOR) # Changed: ÊñπÂêë‰∏çÂêå!

        comparison_group = VGroup(mag_text, comp_text, dir_text).arrange(DOWN, buff=0.3, aligned_edge=LEFT)
        comparison_group.to_corner(UL, buff=0.5) # Position top-left

        # Conclusion Text
        conclusion = Text(
            "Conclusion: Same Magnitude ‚â† Same Components\n(Direction must also be the same!)", # Changed: ÁªìËÆ∫ÔºöÊ®°ÈïøÁõ∏Âêå ‚â† ÂàÜÈáèÁõ∏Âêå\n(ËøòÈúÄË¶ÅÊñπÂêëÁõ∏ÂêåÔºÅ)
            font_size=40,
            color=MY_TEXT_COLOR,
            line_spacing=0.8, # Adjust line spacing if needed
            should_center=True,
            width = config.frame_width * 0.5 # Limit width
        )
        conclusion.to_edge(UP, buff=0.5)

        # --- TTS Integration ---
        voice_text_04 = "Now let's look at both vectors together. Vector A is (3, 4), and vector B is (5, 0). Their magnitudes are both 5, but their components are clearly different, and they point in different directions. Therefore, our conclusion is: having the same magnitude alone does not guarantee that the vectors' components are the same. For vectors to be equal, both magnitude and direction must be identical!" # Changed: Áé∞Âú®Êàë‰ª¨Êää‰∏§‰∏™ÂêëÈáèÊîæÂú®‰∏ÄËµ∑Áúã„ÄÇÂêëÈáè A ÊòØ (3, 4)ÔºåÂêëÈáè B ÊòØ (5, 0)„ÄÇÂÆÉ‰ª¨ÁöÑÊ®°ÈïøÈÉΩÊòØ 5Ôºå‰ΩÜÊòØÂÆÉ‰ª¨ÁöÑÂàÜÈáèÊòæÁÑ∂‰∏çÂêåÔºåÊåáÂêëÁöÑÊñπÂêë‰πü‰∏çÂêå„ÄÇÊâÄ‰ª•ÔºåÊàë‰ª¨ÁöÑÁªìËÆ∫ÊòØÔºö‰ªÖ‰ªÖÊ®°ÈïøÁõ∏ÂêåÔºåÂπ∂‰∏çËÉΩ‰øùËØÅÂêëÈáèÁöÑÂàÜÈáè‰πüÁõ∏Âêå„ÄÇÂêëÈáèÁõ∏Á≠âÊÑèÂë≥ÁùÄÊ®°ÈïøÂíåÊñπÂêëÈÉΩÂøÖÈ°ªÁõ∏ÂêåÔºÅ
        with custom_voiceover_tts(voice_text_04) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 4 TTS audio failed or has zero duration.")

            subtitle_voice = Text(
                voice_text_04, font_size=32, color=MY_TEXT_COLOR,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Animations
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),
                    Create(vec_A), Write(vec_A_label),
                    Create(vec_B), Write(vec_B_label),
                    lag_ratio=0.1 # Stagger the appearance slightly
                ),
                run_time=2.5
            )
            # Show comparison points
            self.play(FadeIn(mag_text, shift=RIGHT*0.2), run_time=1.0)
            self.play(FadeIn(comp_text, shift=RIGHT*0.2), run_time=1.0)
            self.play(FadeIn(dir_text, shift=RIGHT*0.2), run_time=1.0)
            self.wait(0.5)
            # Show conclusion
            self.play(FadeIn(conclusion, scale=0.8), run_time=1.5) # Scale in for emphasis

            # Calculate wait time
            anim_time = 2.5 + 1.0 + 1.0 + 1.0 + 0.5 + 1.5 # Total animation time
            fade_out_duration = 1.0
            if tracker.duration > 0:
                elapsed_time = anim_time
                remaining_time = tracker.duration - elapsed_time - fade_out_duration
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.5) # Wait if no audio

            # Keep conclusion, fade subtitle
            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)
            # Fade out comparison details, keep vectors and conclusion
            self.play(FadeOut(comparison_group), run_time=0.5)

        self.wait(1.5) # Hold final comparison screen


# --- Main execution block ---
if __name__ == "__main__":
    # Basic configuration
    config.pixel_height = 1080
    config.pixel_width = 1920
    config.frame_rate = 30
    config.output_file = "CombinedScene" # Output filename
    config.disable_caching = True # Disable caching

    # Set output directory using placeholder
    # IMPORTANT: Ensure this placeholder is correctly replaced by your Java process
    config.media_dir = "./#(output_path)" # Placeholder for output directory

    # Create and render the scene
    scene = CombinedScene()
    scene.render()

    print(f"Scene rendering finished. Output should be in: {config.media_dir}")
    # Check if the file exists (optional verification)
    output_file_path = os.path.join(config.media_dir, f"{config.output_file}.mp4")
    if os.path.exists(output_file_path):
        print(f"Output file found: {output_file_path}")
    else:
        print(f"Warning: Output file not found at expected location: {output_file_path}")
```

## Video

‰∏≠ÊñáÁâàÊú¨
https://manim.collegebot.ai/cache/499169744602697728/videos/1080p30/CombinedScene.mp4

English Version
https://manim.collegebot.ai/cache/499171675542818816/videos/1080p30/CombinedScene.mp4
