# 在 Android 上使用 tio-boot 运行 HTTP 服务

[[toc]]

本文档详细介绍了如何在 Android 设备上使用 `tio-boot` 框架运行轻量级 HTTP 服务。`tio-boot` 基于 TIO 通信协议，实现了高性能、易用的 HTTP 服务能力，非常适合嵌入式或移动端场景。以下各步将带你从环境准备，到代码编写，再到最终测试，一气呵成地完成部署。

## 一、前提准备

* Android Studio（或其他兼容的 IDE）
* 至少 Android 5.0（API 21）及以上设备或模拟器
* 网络权限及存储权限已在 `AndroidManifest.xml` 中声明
* 依赖库需要从 Maven 仓库拉取，请确保 Gradle 能正常访问外网或已配置内网镜像

## 二、添加依赖项

在模块级 `build.gradle` 中引入以下依赖：

```groovy
dependencies {
  // Android 端视图注入和工具类
  implementation 'com.litongjava:android-view-inject:1.0'
  implementation 'com.litongjava:litongjava-android-utils:1.0.2'
  // 核心 HTTP 服务框架
  implementation 'com.litongjava:tio-boot:2.0.1'
  // 可选：AOP 支持（如不在 Controller 中使用，可移除以节省包体积）
  implementation 'com.litongjava:jfinal-aop:1.3.6'
}
```

> **提示**：若项目追求极致性能，并且不需要在 Android 代码中依赖注解式 Controller 扫描，可去掉 `jfinal-aop` 依赖。

## 三、编写 HTTP 处理器（Handler）

新建一个普通 Java 类 `HelloHandler`，用于演示最基本的 GET 请求：

```java
package com.litongjava.android.tio.boot.controller;

import com.litongjava.tio.http.common.HttpRequest;
import com.litongjava.tio.http.common.HttpResponse;
import com.litongjava.tio.http.server.util.Resps;

public class HelloHandler {

  // 响应 /hello 返回纯文本 "hello"
  public HttpResponse hello(HttpRequest httpRequest) {
    return Resps.txt(httpRequest, "hello");
  }

  // 响应 /hi 返回纯文本 "hi"
  public HttpResponse hi(HttpRequest httpRequest) {
    return Resps.txt(httpRequest, "hi");
  }
}
```

## 四、定义注解式 Controller

借助注解路由支持，将方法绑定到路由路径：

```java
package com.litongjava.android.tio.boot.controller;

import com.litongjava.annotation.RequestPath;
import com.litongjava.tio.boot.http.TioRequestContext;
import com.litongjava.tio.http.common.HttpRequest;

@RequestPath  // 表示此类下的方法需被扫描并注册
public class IndexController {

  @RequestPath  // 绑定到根路径 “/”
  public String index(HttpRequest request) {
    // 通过 TioRequestContext 获取底层 HttpResponse 对象
    System.out.println("访问根路径，Request = " + request);
    return "index";  // 返回视图名称或纯文本
  }

  // 绑定到 /student，自动将请求参数解析为 StudentReqVo 对象
  public StudentReqVo student(StudentReqVo reqVo) {
    return reqVo;
  }
}
```

## 五、配置服务器路由与启动类

1. **创建配置类** `TioBootServerConfig`：

```java
package com.litongjava.android.tio.boot.controller;

import com.litongjava.context.BootConfiguration;
import com.litongjava.tio.boot.http.handler.controller.TioBootHttpControllerRouter;
import com.litongjava.tio.boot.server.TioBootServer;
import com.litongjava.tio.http.server.router.HttpRequestRouter;

import java.util.ArrayList;
import java.util.List;

public class TioBootServerConfig implements BootConfiguration {
    @Override
    public void config() throws Exception {
        TioBootHttpControllerRouter controllerRouter = TioBootServer.me().getControllerRouter();
        if (controllerRouter != null) {
            List<Class<?>> scannedClasses = new ArrayList<>();
            scannedClasses.add(IndexController.class);
            controllerRouter.addControllers(scannedClasses);
        }

        HttpRequestRouter requestRouter = TioBootServer.me().getRequestRouter();
        if (requestRouter != null) {
            HelloHandler helloHandler = new HelloHandler();
            requestRouter.add("/hi", helloHandler::hi);
            requestRouter.add("/hello", helloHandler::hello);
        }

    }
}
```

2. **启动服务的主类** `TioBootServerApp`：

```java
package com.litongjava.android.tio.boot.controller;


import com.blankj.utilcode.util.NetworkUtils;
import com.litongjava.tio.boot.TioApplication;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TioBootServerApp {
    private static Logger log = LoggerFactory.getLogger(TioBootServerApp.class);

    public static void run() {
        long start = System.currentTimeMillis();
        TioBootServerConfig tioBootServerConfig = new TioBootServerConfig();
        String[] args = new String[]{"--server.port=10051"};
        TioApplication.run(TioBootServerApp.class, tioBootServerConfig, args);
        String ipAddressByWifi = NetworkUtils.getIpAddressByWifi();
        log.info("ipAddressByWifi:{}", ipAddressByWifi);
        long end = System.currentTimeMillis();
        System.out.println((end - start) + "(ms)");
    }
}

```

## 六、配置 AndroidManifest.xml

在根 `AndroidManifest.xml` 中，声明网络及存储权限：

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.litongjava.android.tio.boot">

  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />


  <application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.Litongjavatiobootforandroidstudy">
    <activity android:name=".MainActivity">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />

        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>

</manifest>
```

## 七、设计简单 UI（启动按钮）

`res/layout/activity_main.xml`：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  tools:context=".MainActivity">

  <Button
    android:id="@+id/startBtn"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@color/purple_200"
    android:text="启动"></Button>

</LinearLayout>
```

## 八、在 MainActivity 中获取权限并启动服务

```java
package com.litongjava.android.tio.boot;

import android.Manifest;
import android.os.Bundle;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;

import com.litongjava.android.tio.boot.controller.TioBootServerApp;
import com.litongjava.android.utils.acp.AcpUtils;
import com.litongjava.android.utils.toast.ToastUtils;
import com.litongjava.android.view.inject.annotation.FindViewByIdLayout;
import com.litongjava.android.view.inject.annotation.OnClick;
import com.litongjava.android.view.inject.utils.ViewInjectUtils;
import com.mylhyl.acp.AcpListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;

@FindViewByIdLayout(R.layout.activity_main)
public class MainActivity extends AppCompatActivity {
  private Logger log = LoggerFactory.getLogger(this.getClass());

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //setContentView(R.layout.activity_main);
    ViewInjectUtils.injectActivity(this, this);
  }

  @OnClick(R.id.startBtn)
  public void startBtnOnClick(View view) {
    String[] permissions = {
      //写入外部设备权限
      Manifest.permission.ACCESS_NETWORK_STATE,
      Manifest.permission.ACCESS_WIFI_STATE,
      Manifest.permission.INTERNET,
      Manifest.permission.READ_EXTERNAL_STORAGE,
      Manifest.permission.WRITE_EXTERNAL_STORAGE

    };
    //创建acpListener
    AcpListener acpListener = new AcpListener() {
      @Override
      public void onGranted() {
        TioBootServerApp.run();
      }

      @Override
      public void onDenied(List<String> permissions) {
        ToastUtils.defaultToast(getApplicationContext(), permissions.toString() + "权限拒绝,无法写入日志");
      }
    };

    AcpUtils.requestPermissions(this, permissions, acpListener);

  }
}
```

启动后，点击界面上的启动按钮,你将会在 Logcat 中看到类似输出：

```
2025-07-03 22:08:41.363 [main] WARN  Prop.<init>:72 - failed to create fileapp.propertiesRead-only file system
2025-07-03 22:08:41.364 [main] INFO  EnvUtils.load:285 - load:app.properties
2025-07-03 22:08:41.365 [main] INFO  EnvUtils.load:307 - app.env:null app.name:null
2025-07-03 22:08:41.367 [main] INFO  TioApplicationContext.run:110 - Scanned classes count: 0
2025-07-03 22:08:41.370 [main] INFO  TioApplicationContext.configureHttp:502 - Server session enabled: false
2025-07-03 22:08:41.371 [main] INFO  TioApplicationContext.run:147 - Using cache: class com.litongjava.tio.utils.cache.mapcache.ConcurrentMapCacheFactory
2025-07-03 22:08:41.375 [main] INFO  TioApplicationContext.run:199 - Server heartbeat timeout: 0
2025-07-03 22:08:41.379 [main] INFO  TioServer.start:95 - tio-boot workerThreads:32
Compat change id reported: 288912692; UID 10350; state: DISABLED
2025-07-03 22:08:41.387 [main] INFO  Threads.getTioExecutor:93 - new worker thead pool:com.litongjava.tio.utils.thread.pool.SynThreadPoolExecutor@793e53c[Running, pool size = 1, active threads = 0, queued tasks = 0, completed tasks = 0]
2025-07-03 22:08:41.388 [main] INFO  TioApplicationContext.run:333 - HTTP handler:
{
  "/hi": "com.litongjava.android.tio.boot.controller.-$$Lambda$yj_UDBEIbM3h-OA3eprGlvm4tbY@23912c5",
  "/hello": "com.litongjava.android.tio.boot.controller.-$$Lambda$H2BQOHvwVwZqr4LaO93a0lg1uWk@f63341a"
}
2025-07-03 22:08:41.403 [main] INFO  TioBootHttpControllerRouter.printMapping:454 - controller method mapping
{
  "": "com.litongjava.android.tio.boot.controller.IndexController.index()",
  "/student": "com.litongjava.android.tio.boot.controller.IndexController.student()"
}
2025-07-03 22:08:41.403 [main] INFO  TioApplicationContext.run:363 - Initialization times (ms): Total: 36, Scan Classes: 1, Init Server: 9, Config: 1, Server: 10, Route: 15
2025-07-03 22:08:41.404 [main] INFO  TioApplicationContext.printUrl:380 - Server port: 10051
2025-07-03 22:08:41.404 [main] INFO  TioApplicationContext.printUrl:391 - Access URL: http://localhost:10051
2025-07-03 22:08:41.407 [main] INFO  TioBootServerApp.run:22 - ipAddressByWifi:192.168.50.7
51(ms)

```

## 九、功能验证

在同一局域网内，使用浏览器或 curl 访问：

* `http://192.168.50.7:10051/hi` → 应返回 `hi`
* `http://192.168.50.7:10051/hello` → 应返回 `hello`
* `http://192.168.50.7:10051/` → 应返回 `index`（或相应视图名内容）

## 十、关于 Controller 扫描的说明

Android 平台的 DexClassLoader 不会像标准 Java ClassLoader 那样，将 `.dex` 文件暴露为资源，因此无法通过 `ClassLoader.getResources()` 枚举出注解类。`tio-boot` 在 Android 上暂不支持自动扫描 APK 内的 Controller，只能手动在配置类中显式添加。

> 源码及示例项目：
> [https://github.com/litongjava/java-ee-tio-boot-study/tree/main/tio-boot-latest-study/tio-boot-android](https://github.com/litongjava/java-ee-tio-boot-study/tree/main/tio-boot-latest-study/tio-boot-android)

---

至此，一个基于 `tio-boot` 的 Android 内嵌 HTTP 服务即已完整搭建，可根据业务需求进一步扩展路由、添加拦截器或集成非阻塞 I/O。祝你开发顺利！
