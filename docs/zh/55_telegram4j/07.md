# å¢åŠ å‘½ä»¤èœå•

## å¼•è¨€

æœ¬æ–‡æ¡£æ—¨åœ¨æŒ‡å¯¼å¼€å‘è€…å¦‚ä½•ä¸º Telegram æœºå™¨äººæ·»åŠ å‘½ä»¤èœå•ï¼Œä»¥æå‡ç”¨æˆ·äº¤äº’ä½“éªŒã€‚é€šè¿‡è¯¦ç»†çš„ä»£ç ç¤ºä¾‹å’Œè§£é‡Šï¼Œè¯»è€…å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ BotFather æˆ–é€šè¿‡ç¼–ç¨‹æ–¹å¼åŠ¨æ€ç®¡ç†æœºå™¨äººå‘½ä»¤èœå•ã€‚æœ¬æ–‡è¿˜ä»‹ç»äº†å¦‚ä½•è¿‡æ»¤å‘½ä»¤æ¶ˆæ¯ä»¥åŠå°è£…è·¯ç”±ï¼Œä»¥å®ç°æ›´çµæ´»å’Œå¯ç»´æŠ¤çš„æœºå™¨äººåŠŸèƒ½ã€‚

## å¢åŠ å‘½ä»¤èœå•

ä¸ºæœºå™¨äººå¢åŠ å‘½ä»¤èœå•æœ‰ä¸¤ç§ä¸»è¦æ–¹å¼ï¼š

- é€šè¿‡ **BotFather**
- é€šè¿‡ **ä»£ç **

### é€šè¿‡ **BotFather** å¢åŠ èœå•

- /mybots
- é€‰æ‹©æœºå™¨äºº
- Edit Bot
- Edit Commands
  å‘é€ä¸‹é¢çš„æ¶ˆæ¯

```plantext
start - é¦–é¡µ
```

### é€šè¿‡ä»£ç å¢åŠ å‘½ä»¤èœå•

ä»¥ä¸‹ä»£ç ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•é€šè¿‡ç¼–ç¨‹æ–¹å¼ä¸º Telegram æœºå™¨äººè®¾ç½®å’Œåˆ é™¤å‘½ä»¤èœå•ã€‚é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€ç®¡ç†æœºå™¨äººçš„å‘½ä»¤ï¼Œæä¾›æ›´å¤§çš„çµæ´»æ€§ã€‚

```java
package com.litongjava.gpt.translator.config;

import java.nio.file.Path;
import java.time.Duration;
import java.util.List;
import java.util.function.Function;

import com.litongjava.annotation.AConfiguration;
import com.litongjava.annotation.Initialization;
import com.litongjava.gpt.translator.client.TelegramClient;
import com.litongjava.gpt.translator.predicate.UserMessagePredicate;
import com.litongjava.gpt.translator.telegram.adapter.MyBotEventAdapter;
import com.litongjava.gpt.translator.telegram.function.TranslateFunction;
import com.litongjava.tio.boot.server.TioBootServer;
import com.litongjava.tio.utils.environment.EnvUtils;

import lombok.extern.slf4j.Slf4j;
import reactor.util.retry.Retry;
import telegram4j.core.MTProtoBootstrap;
import telegram4j.core.MTProtoTelegramClient;
import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.core.spec.BotCommandScopeSpec;
import telegram4j.mtproto.RpcException;
import telegram4j.mtproto.store.FileStoreLayout;
import telegram4j.mtproto.store.StoreLayoutImpl;
import telegram4j.tl.BotCommand;
import telegram4j.tl.ImmutableBotCommand;

@Slf4j
@AConfiguration
public class TelegramTranslateBot {

  @Initialization
  public void config() {
    // ä»ç¯å¢ƒå˜é‡è·å– Telegram API é…ç½®ä¿¡æ¯
    int apiId = EnvUtils.getInt("telegram.api.id");
    String apiHash = EnvUtils.getStr("telegram.api.hash");
    String botAuthToken = EnvUtils.getStr("telegram.bot.auth.token");

    String botId = botAuthToken.split(":")[0];
    // åˆ›å»ºå¹¶è¿æ¥ MTProto Telegram å®¢æˆ·ç«¯
    MTProtoBootstrap bootstrap = MTProtoTelegramClient.create(apiId, apiHash, botAuthToken);

    StoreLayoutImpl storeLayoutImpl = new StoreLayoutImpl(Function.identity());
    FileStoreLayout storeLayout = new FileStoreLayout(storeLayoutImpl, Path.of("t4j-bot_" + botId + ".bin"));
    bootstrap.setStoreLayout(storeLayout);

    MTProtoTelegramClient client = bootstrap.connect().block();
    if (client == null) {
      log.error("Failed to connect to Telegram MTProto client.");
      return;
    }
    log.info("Telegram MTProto client connected.");

    //deleteCommand(client);
    setCommand(client);

    // è·å–è‡ªå·±çš„id
    long selfId = client.getSelfId().asLong();
    log.info("self id:{}", selfId);

    // é…ç½®äº‹ä»¶ç›‘å¬å™¨ï¼šæ¥æ”¶ SendMessageEventï¼Œè¿‡æ»¤ç”¨æˆ·æ¶ˆæ¯ï¼Œå¹¶åº”ç”¨ç¿»è¯‘åŠŸèƒ½
    client.on(SendMessageEvent.class)
        //
        .filter(new UserMessagePredicate(selfId)::test).flatMap(new TranslateFunction()::apply)
        //
        .delayElements(Duration.ofSeconds(1)) // æ¯ç§’æœ€å¤šå‘é€ä¸€æ¡æ¶ˆæ¯
        //
        .doOnError(e -> log.error("å¤„ç†æ¶ˆæ¯æ—¶å‘ç”Ÿé”™è¯¯", e))
        //
        .retryWhen(Retry.backoff(5, Duration.ofSeconds(1)).filter(e -> e instanceof RpcException))
        //
        .subscribe();

    client.on(new MyBotEventAdapter()).subscribe();

    TelegramClient.client = client;

    // é˜²æ­¢ä¸»çº¿ç¨‹é˜»å¡ï¼Œç›‘æ§å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
    //    TioThreadUtils.submit(() -> {
    //      client.onDisconnect().block();
    //      log.info("Telegram client disconnected.");
    //    });

    // åœ¨æœåŠ¡å™¨å…³é—­æ—¶ï¼Œæ–­å¼€ Telegram å®¢æˆ·ç«¯è¿æ¥
    HookCan.me().addDestroyMethod(client::disconnect);


  }

  private void deleteCommand(MTProtoTelegramClient client) {
    client.resetCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "")
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully deleted!"))
        //
        .doOnError(e -> log.error("Failed to delete commands.", e)).block();
  }

  private void setCommand(MTProtoTelegramClient client) {
    BotCommand startCommand = ImmutableBotCommand.of("start", "Start using the bot");
    BotCommand aboutCommand = ImmutableBotCommand.of("about", "About this bot");

    List<BotCommand> commands = List.of(startCommand, aboutCommand);

    client.setCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "", commands)
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully set!"))
        //
        .doOnError(e -> log.error("Failed to set commands.", e)).block();
  }
}
```

ä¸Šé¢çš„ä»£ç æ¼”ç¤ºäº†å¦‚ä½•é€šè¿‡ä»£ç å¢åŠ å‘½ä»¤èœå•ï¼Œå¢åŠ å®Œæˆåæ˜¾ç¤ºå¦‚ä¸‹ï¼š

![å‘½ä»¤èœå•æ¼”ç¤º](image.png)

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œ`TelegramTranslateBot` ç±»é€šè¿‡ä»£ç æ–¹å¼ä¸º Telegram æœºå™¨äººè®¾ç½®å’Œåˆ é™¤å‘½ä»¤èœå•ã€‚ä¸‹é¢å°†è¯¦ç»†è§£é‡Š `setCommand` å’Œ `deleteCommand` ä¸¤ä¸ªæ–¹æ³•çš„å®ç°åŠå…¶å·¥ä½œåŸç†ã€‚

## é€šè¿‡ä»£ç å¢åŠ å‘½ä»¤èœå• ä»£ç è§£é‡Š

### `setCommand` æ–¹æ³•

#### åŠŸèƒ½

`setCommand` æ–¹æ³•ç”¨äºä¸ºæœºå™¨äººè®¾ç½®å‘½ä»¤èœå•ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œè®¾ç½®äº†ä¸¤ä¸ªå‘½ä»¤ï¼š`/start` å’Œ `/about`ï¼Œåˆ†åˆ«å¯¹åº”â€œå¼€å§‹ä½¿ç”¨æœºå™¨äººâ€å’Œâ€œå…³äºæ­¤æœºå™¨äººâ€çš„æè¿°ã€‚è®¾ç½®èœå•æ—¶æ— éœ€åœ¨å‘½ä»¤å‰æ·»åŠ æ–œæ ï¼ˆ"/"ï¼‰ï¼Œåªéœ€ç›´æ¥æ·»åŠ å‘½ä»¤å³å¯ã€‚èœå•è®¾ç½®ä¸€æ¬¡åï¼Œåªè¦ä¸åˆ é™¤ï¼Œå³å¯æ°¸ä¹…æœ‰æ•ˆã€‚

#### ä»£ç è§£æ

```java
private void setCommand(MTProtoTelegramClient client) {
    BotCommand startCommand = ImmutableBotCommand.of("start", "Start using the bot");
    BotCommand aboutCommand = ImmutableBotCommand.of("about", "About this bot");

    List<BotCommand> commands = List.of(startCommand, aboutCommand);

    client.setCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "", commands)
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully set!"))
        //
        .doOnError(e -> log.error("Failed to set commands.", e)).block();
}
```

#### è¯¦ç»†è¯´æ˜

1. **å®šä¹‰å‘½ä»¤**

   ```java
   BotCommand startCommand = ImmutableBotCommand.of("start", "Start using the bot");
   BotCommand aboutCommand = ImmutableBotCommand.of("about", "About this bot");
   ```

   - ä½¿ç”¨ `ImmutableBotCommand.of` æ–¹æ³•åˆ›å»ºä¸¤ä¸ªä¸å¯å˜çš„ `BotCommand` å¯¹è±¡ï¼Œåˆ†åˆ«ä»£è¡¨ `/start` å’Œ `/about` å‘½ä»¤ï¼Œå¹¶ä¸ºå…¶æ·»åŠ æè¿°ã€‚

2. **åˆ›å»ºå‘½ä»¤åˆ—è¡¨**

   ```java
   List<BotCommand> commands = List.of(startCommand, aboutCommand);
   ```

   - å°†ä¸Šè¿°ä¸¤ä¸ªå‘½ä»¤æ·»åŠ åˆ°ä¸€ä¸ª `List` ä¸­ï¼Œä»¥ä¾¿ä¸€æ¬¡æ€§è®¾ç½®å¤šä¸ªå‘½ä»¤ã€‚

3. **è®¾ç½®å‘½ä»¤**

   ```java
   client.setCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "", commands)
   ```

   - è°ƒç”¨ `client.setCommands` æ–¹æ³•ï¼Œå°†å‘½ä»¤åˆ—è¡¨åº”ç”¨åˆ°é»˜è®¤èŒƒå›´ (`BotCommandScopeSpec.Type.DEFAULT`)ã€‚
   - ç¬¬äºŒä¸ªå‚æ•°ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸ä½¿ç”¨ç‰¹å®šçš„è¯­è¨€ç¯å¢ƒã€‚

4. **é‡è¯•æœºåˆ¶**

   ```java
   .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
   ```

   - ä½¿ç”¨ Reactor çš„ `retryWhen` æ“ä½œç¬¦ï¼Œé…ç½®åœ¨å¤±è´¥æ—¶è¿›è¡Œé‡è¯•ï¼Œæœ€å¤šé‡è¯• 3 æ¬¡ï¼Œæ¯æ¬¡é‡è¯•ä¹‹é—´é—´éš” 2 ç§’ã€‚

5. **æ—¥å¿—è®°å½•**

   ```java
   .doOnSuccess(v -> log.info("Commands successfully set!"))
   .doOnError(e -> log.error("Failed to set commands.", e))
   ```

   - æˆåŠŸè®¾ç½®å‘½ä»¤åï¼Œè®°å½•æˆåŠŸæ—¥å¿—ã€‚
   - å¦‚æœè®¾ç½®å¤±è´¥ï¼Œè®°å½•é”™è¯¯æ—¥å¿—ã€‚

6. **é˜»å¡ç­‰å¾…**

   ```java
   .block();
   ```

   - é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å‘½ä»¤è®¾ç½®æ“ä½œå®Œæˆã€‚è¿™åœ¨åˆå§‹åŒ–é˜¶æ®µç¡®ä¿å‘½ä»¤å·²ç»è®¾ç½®å®Œæ¯•ã€‚

### `deleteCommand` æ–¹æ³•

#### åŠŸèƒ½

`deleteCommand` æ–¹æ³•ç”¨äºåˆ é™¤æœºå™¨äººå½“å‰çš„æ‰€æœ‰å‘½ä»¤èœå•ã€‚è¿™åœ¨éœ€è¦é‡ç½®å‘½ä»¤æˆ–ç§»é™¤ç°æœ‰å‘½ä»¤æ—¶ä½¿ç”¨ã€‚

#### ä»£ç è§£æ

```java
private void deleteCommand(MTProtoTelegramClient client) {
    client.resetCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "")
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully deleted!"))
        //
        .doOnError(e -> log.error("Failed to delete commands.", e)).block();
}
```

#### è¯¦ç»†è¯´æ˜

1. **é‡ç½®å‘½ä»¤**

   ```java
   client.resetCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "")
   ```

   - è°ƒç”¨ `client.resetCommands` æ–¹æ³•ï¼Œé’ˆå¯¹é»˜è®¤èŒƒå›´ (`BotCommandScopeSpec.Type.DEFAULT`) é‡ç½®å‘½ä»¤ã€‚
   - ç¬¬äºŒä¸ªå‚æ•°ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸ä½¿ç”¨ç‰¹å®šçš„è¯­è¨€ç¯å¢ƒã€‚

2. **é‡è¯•æœºåˆ¶**

   ```java
   .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
   ```

   - ç±»ä¼¼äº `setCommand` æ–¹æ³•ï¼Œé…ç½®åœ¨å¤±è´¥æ—¶è¿›è¡Œæœ€å¤š 3 æ¬¡é‡è¯•ï¼Œæ¯æ¬¡é—´éš” 2 ç§’ã€‚

3. **æ—¥å¿—è®°å½•**

   ```java
   .doOnSuccess(v -> log.info("Commands successfully deleted!"))
   .doOnError(e -> log.error("Failed to delete commands.", e))
   ```

   - æˆåŠŸåˆ é™¤å‘½ä»¤åï¼Œè®°å½•æˆåŠŸæ—¥å¿—ã€‚
   - å¦‚æœåˆ é™¤å¤±è´¥ï¼Œè®°å½•é”™è¯¯æ—¥å¿—ã€‚

4. **é˜»å¡ç­‰å¾…**

   ```java
   .block();
   ```

   - é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å‘½ä»¤åˆ é™¤æ“ä½œå®Œæˆã€‚

#### æ³¨æ„äº‹é¡¹

- åœ¨ `config` æ–¹æ³•ä¸­ï¼Œ`deleteCommand(client);` è¢«æ³¨é‡Šæ‰äº†ã€‚è¿™æ„å‘³ç€é»˜è®¤æƒ…å†µä¸‹ä¸ä¼šåˆ é™¤ç°æœ‰å‘½ä»¤ï¼Œåªæœ‰åœ¨éœ€è¦é‡ç½®å‘½ä»¤æ—¶æ‰ä¼šå¯ç”¨è¯¥æ–¹æ³•ã€‚
- ä½¿ç”¨é˜»å¡æ“ä½œ (`block()`) åœ¨åˆå§‹åŒ–é˜¶æ®µæ˜¯åˆç†çš„ï¼Œä½†åœ¨å…¶ä»–ä¸Šä¸‹æ–‡ä¸­åº”è°¨æ…ä½¿ç”¨ï¼Œä»¥é¿å…é˜»å¡éé˜»å¡å¼åº”ç”¨çš„æ‰§è¡Œæµç¨‹ã€‚

### æ€»ç»“

é€šè¿‡ `setCommand` å’Œ `deleteCommand` æ–¹æ³•ï¼Œ`TelegramTranslateBot` ç±»å®ç°äº†é€šè¿‡ä»£ç æ–¹å¼åŠ¨æ€ç®¡ç† Telegram æœºå™¨äººçš„å‘½ä»¤èœå•ã€‚è¿™ç§æ–¹æ³•ç›¸æ¯”ä½¿ç”¨ BotFather æ›´åŠ çµæ´»ï¼Œé€‚ç”¨äºéœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€è°ƒæ•´å‘½ä»¤çš„åœºæ™¯ã€‚æ­¤å¤–ï¼Œä»£ç ä¸­é‡‡ç”¨äº†é‡è¯•æœºåˆ¶å’Œæ—¥å¿—è®°å½•ï¼Œå¢å¼ºäº†ç³»ç»Ÿçš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## è¿‡æ»¤å‘½ä»¤æ¶ˆæ¯

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬å¢åŠ äº† `SendMessageEvent` å’Œ `MyBotEventAdapter` çš„ç›‘å¬ã€‚å½“æ¶ˆæ¯å‘é€åˆ°æœ¬ç¨‹åºæ—¶ï¼Œ`MyBotEventAdapter` å’Œ `SendMessageEvent` å¯¹åº”çš„ç›‘å¬å™¨éƒ½ä¼šå¤„ç†æ¶ˆæ¯ã€‚ä¸ºäº†é¿å…å¤„ç†å‘½ä»¤æ¶ˆæ¯ï¼Œæˆ‘ä»¬åœ¨ `UserMessagePredicate` ä¸­å¢åŠ äº†è¿‡æ»¤é€»è¾‘ã€‚å‘½ä»¤æ¶ˆæ¯çš„ `entities` ç±»å‹ä¸º `MessageEntityBotCommand`ã€‚

ä»¥ä¸‹æ˜¯å‘½ä»¤æ¶ˆæ¯çš„æ—¥å¿—ç¤ºä¾‹ï¼š

```log
SendMessageEvent{
	message=Message{data=Variant2{t1=BaseMessage#38116ee0{flags=10000000, id=1822, fromId=null, peerId=PeerUser#59511722{userId=my_chat_id}, fwdFrom=null, viaBotId=null, replyTo=null, date=1733760693, message='/start', media=null, replyMarkup=null,

		entities=[MessageEntityBotCommand#6cef8ac7{offset=0, length=6}], views=null, forwards=null, replies=null, editDate=null, postAuthor='null', groupedId=null, reactions=null, restrictionReason=null, ttlPeriod=null}}},

	chat=PrivateChat{user=User{minData=BaseUser#abb5f120{flags=10010000000000000001101011, flags2=10000, id=my_chat_id, accessHash=-6745242867060598026, firstName='è‹é‡Œå—', lastName='null', username='xpankou', phone='null', photo=BaseUserProfilePhoto#82d1f706{flags=0, photoId=5129962608709971087, strippedThumb=null, dcId=1}, status=UserStatusRecently#e26f42f1{}, botInfoVersion=null, restrictionReason=null, botInlinePlaceholder='null', langCode='zh-hans', emojiStatus=null, usernames=null, storiesMaxId=null}, fullData=null}, selfUser=User{minData=BaseUser#abb5f120{flags=10000010001100010000001011, flags2=10010, id=7847170133, accessHash=-4262855346709871929, firstName='my-translator', lastName='null', username='litongjava_bot', phone='null', photo=null, status=null, botInfoVersion=3, restrictionReason=null, botInlinePlaceholder='Search...', langCode='null', emojiStatus=null, usernames=null, storiesMaxId=null}, fullData=null}},

	author=User{minData=BaseUser#abb5f120{flags=10010000000000000001101011, flags2=10000, id=my_chat_id, accessHash=-6745242867060598026, firstName='è‹é‡Œå—', lastName='null', username='xpankou', phone='null', photo=BaseUserProfilePhoto#82d1f706{flags=0, photoId=5129962608709971087, strippedThumb=null, dcId=1}, status=UserStatusRecently#e26f42f1{}, botInfoVersion=null, restrictionReason=null, botInlinePlaceholder='null', langCode='zh-hans', emojiStatus=null, usernames=null, storiesMaxId=null}, fullData=null}
}
```

### `UserMessagePredicate` ç±»

```java
package com.litongjava.gpt.translator.predicate;

import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

import lombok.extern.slf4j.Slf4j;
import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.core.object.MentionablePeer;
import telegram4j.core.object.Message;
import telegram4j.core.object.MessageEntity;
import telegram4j.core.object.chat.Chat;

@Slf4j
public class UserMessagePredicate implements Predicate<SendMessageEvent> {
  private long botId;

  public UserMessagePredicate(long selfId) {
    this.botId = selfId;
  }

  @Override
  public boolean test(SendMessageEvent event) {
    // log.info("e:{}", event);

    Optional<MentionablePeer> optionalAuthor = event.getAuthor();
    Optional<Chat> optionalChat = event.getChat();
    // é˜²æ­¢æœºå™¨äººå¤„ç†è‡ªå·±å‘é€çš„æ¶ˆæ¯
    // å¦‚æœæ¶ˆæ¯çš„å‘é€è€…ä¿¡æ¯ä¸å­˜åœ¨ï¼Œè¯´æ˜å¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ï¼Œå¿½ç•¥
    if (optionalAuthor.isEmpty()) {
      log.info("æ¶ˆæ¯å‘é€è€…ä¿¡æ¯ç¼ºå¤±ï¼Œå¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ã€‚");
      return false;
    }
    if (optionalChat.isEmpty()) {
      log.info("æ¶ˆæ¯ä¿¡æ¯ç¼ºå¤±ï¼Œå¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ã€‚");
      return false;
    }
    long messageAuthorId = optionalAuthor.get().getId().asLong();
    if (botId == messageAuthorId) {
      log.info("è·å–åˆ°æœºå™¨äººçš„æ¶ˆæ¯");
      return false;
    }
    Message message = event.getMessage();
    String content = message.getContent();
    List<MessageEntity> entities = message.getEntities();
    for (MessageEntity messageEntity : entities) {
      if (messageEntity.getType() == MessageEntity.Type.BOT_COMMAND && messageEntity.getContent().equals(content)) {
        log.info("ä¸å¤„ç†å‘½ä»¤");
        return false;
      }
    }

    return true;
  }
}
```

## å°è£…è·¯ç”±

### TelegramCommandUtils

```java
package com.litongjava.gpt.translator.telegram.common;

import java.util.List;
import java.util.Optional;

import telegram4j.core.object.Message;
import telegram4j.core.object.MessageEntity;

public class TelegramCommandUtils {
  public static Optional<ParsedCommand> parseCommand(Message message) {

    List<MessageEntity> entities = message.getEntities();
    for (MessageEntity entity : entities) {
      if (entity.getType() == MessageEntity.Type.BOT_COMMAND) {
        String commandWithArgs = message.getContent().substring(entity.getOffset(), entity.getOffset() + entity.getLength());
        String[] parts = commandWithArgs.split(" ", 2);
        String command = parts[0].substring(1);
        String args = parts.length > 1 ? parts[1] : "";
        return Optional.of(new ParsedCommand(command, args));
      }
    }
    return Optional.empty();
  }
}
```

### ParsedCommand

```java
package com.litongjava.gpt.translator.telegram.common;
public class ParsedCommand {
  private final String command;
  private final String args;

  public ParsedCommand(String command, String args) {
    this.command = command;
    this.args = args;
  }

  public String getCommand() { return command; }
  public String getArgs() { return args; }
}
```

### TelegramCommandRouter

```java
package com.litongjava.gpt.translator.telegram.common;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import org.reactivestreams.Publisher;

import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.tl.BotCommand;
import telegram4j.tl.ImmutableBotCommand;

public class TelegramCommandRouter {
  public static List<BotCommand> botCommands = new ArrayList<>();
  public static Map<String, Function<SendMessageEvent, Publisher<?>>> mappings = new ConcurrentHashMap<>();

  public static void add(String command, String descripton, Function<SendMessageEvent, Publisher<?>> function) {
    botCommands.add(ImmutableBotCommand.of(command, descripton));
    mappings.put(command, function);
  }

  public static Function<SendMessageEvent, Publisher<?>> find(String command) {
    return mappings.get(command);
  }
}
```

### TelegramCommandDispatcher

```java
package com.litongjava.gpt.translator.telegram.common;

import java.util.function.Function;

import org.reactivestreams.Publisher;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import telegram4j.core.event.domain.message.SendMessageEvent;

@Slf4j
public class TelegramCommandDispatcher {
  public static Publisher<?> dispatch(String command, SendMessageEvent event) {
    Function<SendMessageEvent, Publisher<?>> function = TelegramCommandRouter.find(command);
    if (function != null) {
      return Mono.from(function.apply(event))
          //
          .subscribeOn(Schedulers.boundedElastic())
          //
          .doOnSuccess(v -> log.info("æ‰§è¡Œå‘½ä»¤: " + command))
          //
          .doOnError(e -> log.error("æ‰§è¡Œå‘½ä»¤æ—¶å‡ºé”™: " + command, e))
          //
          .onErrorResume(e -> Mono.empty());
    }
    return Mono.empty();
  }
}
```

## ä½¿ç”¨ MyBotEventAdapter å¤„ç†æ‰€æœ‰æ¶ˆæ¯å’Œæ·»åŠ å‘½ä»¤

### é…ç½® TelegramTranslateBot

ä»¥ä¸‹ä»£ç å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `MyBotEventAdapter` å¤„ç†æ‰€æœ‰æ¶ˆæ¯ï¼Œå¹¶é€šè¿‡å°è£…çš„è·¯ç”±æ·»åŠ å‘½ä»¤ã€‚

```java
package com.litongjava.gpt.translator.config;

import java.nio.file.Path;
import java.time.Duration;
import java.util.function.Function;

import com.litongjava.annotation.AConfiguration;
import com.litongjava.annotation.Initialization;
import com.litongjava.gpt.translator.client.TelegramClient;
import com.litongjava.gpt.translator.telegram.adapter.MyBotEventAdapter;
import com.litongjava.gpt.translator.telegram.common.TelegramCommandRouter;
import com.litongjava.gpt.translator.telegram.function.AboutUsCommandFunction;
import com.litongjava.gpt.translator.telegram.function.StartCommandFunction;
import com.litongjava.tio.boot.server.TioBootServer;
import com.litongjava.tio.utils.environment.EnvUtils;

import lombok.extern.slf4j.Slf4j;
import reactor.util.retry.Retry;
import telegram4j.core.MTProtoBootstrap;
import telegram4j.core.MTProtoTelegramClient;
import telegram4j.core.spec.BotCommandScopeSpec;
import telegram4j.mtproto.RpcException;
import telegram4j.mtproto.store.FileStoreLayout;
import telegram4j.mtproto.store.StoreLayoutImpl;

@Slf4j
@AConfiguration
public class TelegramTranslateBot {

  @Initialization
  public void config() {
    // ä»ç¯å¢ƒå˜é‡è·å– Telegram API é…ç½®ä¿¡æ¯
    int apiId = EnvUtils.getInt("telegram.api.id");
    String apiHash = EnvUtils.getStr("telegram.api.hash");
    String botAuthToken = EnvUtils.getStr("telegram.bot.auth.token");

    String botId = botAuthToken.split(":")[0];
    // åˆ›å»ºå¹¶è¿æ¥ MTProto Telegram å®¢æˆ·ç«¯
    MTProtoBootstrap bootstrap = MTProtoTelegramClient.create(apiId, apiHash, botAuthToken);

    StoreLayoutImpl storeLayoutImpl = new StoreLayoutImpl(Function.identity());
    FileStoreLayout storeLayout = new FileStoreLayout(storeLayoutImpl, Path.of("t4j-bot_" + botId + ".bin"));
    bootstrap.setStoreLayout(storeLayout);

    MTProtoTelegramClient client = bootstrap.connect().block();
    if (client == null) {
      log.error("Failed to connect to Telegram MTProto client.");
      return;
    }
    log.info("Telegram MTProto client connected.");

    //deleteCommand(client);
    setCommand(client);

    // è·å–è‡ªå·±çš„id
    long selfId = client.getSelfId().asLong();
    log.info("self id:{}", selfId);
    client.on(new MyBotEventAdapter(selfId))
        //
        .delayElements(Duration.ofSeconds(1)) // æ¯ç§’æœ€å¤šå‘é€ä¸€æ¡æ¶ˆæ¯
        //
        .doOnError(e -> log.error("å¤„ç†æ¶ˆæ¯æ—¶å‘ç”Ÿé”™è¯¯", e))
        //
        .retryWhen(Retry.backoff(5, Duration.ofSeconds(1)).filter(e -> e instanceof RpcException))
        //
        .subscribe();

    TelegramClient.client = client;

    // é˜²æ­¢ä¸»çº¿ç¨‹é˜»å¡ï¼Œç›‘æ§å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
    //    TioThreadUtils.submit(() -> {
    //      client.onDisconnect().block();
    //      log.info("Telegram client disconnected.");
    //    });

    // åœ¨æœåŠ¡å™¨å…³é—­æ—¶ï¼Œæ–­å¼€ Telegram å®¢æˆ·ç«¯è¿æ¥
    HookCan.me().addDestroyMethod(client::disconnect);

  }

  private void deleteCommand(MTProtoTelegramClient client) {
    client.resetCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "")
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully deleted!"))
        //
        .doOnError(e -> log.error("Failed to delete commands.", e)).block();
  }

  private void setCommand(MTProtoTelegramClient client) {
    TelegramCommandRouter.add("start", "Start using the bot", new StartCommandFunction()::apply);
    TelegramCommandRouter.add("about", "About this bot", new AboutUsCommandFunction()::apply);

    client.setCommands(BotCommandScopeSpec.of(BotCommandScopeSpec.Type.DEFAULT), "", TelegramCommandRouter.botCommands)
        //
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(2)))
        //
        .doOnSuccess(v -> log.info("Commands successfully set!"))
        //
        .doOnError(e -> log.error("Failed to set commands.", e)).block();
  }
}
```

### MyBotEventAdapter

```java
package com.litongjava.gpt.translator.telegram.adapter;

import java.util.List;
import java.util.Optional;

import org.reactivestreams.Publisher;

import com.litongjava.gpt.translator.services.SendMessageEventService;
import com.litongjava.gpt.translator.telegram.common.ParsedCommand;
import com.litongjava.gpt.translator.telegram.common.TelegramCommandDispatcher;
import com.litongjava.gpt.translator.telegram.common.TelegramCommandUtils;
import com.litongjava.gpt.translator.telegram.function.TelegramMessageDispatcher;
import com.litongjava.jfinal.aop.Aop;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import telegram4j.core.event.EventAdapter;
import telegram4j.core.event.domain.inline.CallbackQueryEvent;
import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.core.object.MentionablePeer;
import telegram4j.core.object.Message;
import telegram4j.core.object.MessageEntity;
import telegram4j.core.object.chat.Chat;

@Slf4j
public class MyBotEventAdapter extends EventAdapter {

  private long botId;

  public MyBotEventAdapter(long selfId) {
    this.botId = selfId;
  }

  @Override
  public Publisher<?> onSendMessage(SendMessageEvent event) {
    Message message = event.getMessage();
    Optional<MentionablePeer> optionalAuthor = event.getAuthor();
    Optional<Chat> optionalChat = event.getChat();
    //é˜²æ­¢æœºå™¨äººå¤„ç†è‡ªå·±å‘é€çš„æ¶ˆæ¯
    // å¦‚æœæ¶ˆæ¯çš„å‘é€è€…ä¿¡æ¯ä¸å­˜åœ¨ï¼Œè¯´æ˜å¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ï¼Œå¿½ç•¥
    if (optionalAuthor.isEmpty()) {
      log.info("æ¶ˆæ¯å‘é€è€…ä¿¡æ¯ç¼ºå¤±ï¼Œå¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ã€‚");
      return Mono.empty();
    }
    if (optionalChat.isEmpty()) {
      log.info("æ¶ˆæ¯ä¿¡æ¯ç¼ºå¤±ï¼Œå¯èƒ½æ˜¯æœºå™¨äººè‡ªèº«å‘é€çš„æ¶ˆæ¯ã€‚");
      return Mono.empty();
    }
    long messageAuthorId = optionalAuthor.get().getId().asLong();
    if (botId == messageAuthorId) {
      log.info("è·å–åˆ°æœºäººè‡ªå·±çš„æ¶ˆæ¯");
      return Mono.empty();
    }

    // ç«å¹¶å¿˜è®°ï¼šå¼‚æ­¥ä¿å­˜äº‹ä»¶
    Mono.fromRunnable(() -> {
      try {
        Aop.get(SendMessageEventService.class).save(event);
      } catch (Exception e) {
        log.error("Failed to save event", e);
      }
    }).subscribeOn(Schedulers.boundedElastic()).subscribe();

    List<MessageEntity> entities = message.getEntities();
    if (entities.size() > 0) {
      for (MessageEntity entity : entities) {
        if (entity.getType() == MessageEntity.Type.BOT_COMMAND) {
          Optional<ParsedCommand> parseCommand = TelegramCommandUtils.parseCommand(message);
          return parseCommand.map(parsed -> TelegramCommandDispatcher.dispatch(parsed.getCommand(), event))
              //
              .orElse(Mono.empty());
        }
      }
    } else {
      // å°† dispatch è°ƒç”¨è½¬ä¸ºå¼‚æ­¥ Mono è®¡ç®—
      return Mono.fromCallable(() -> new TelegramMessageDispatcher().dispatch(event))
          //
          .subscribeOn(Schedulers.boundedElastic())
          //
          .flatMap(publisher -> Mono.from(publisher))
          //
          .onErrorResume(e -> {
            log.error("å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™", e);
            return Mono.empty();
          });
    }

    return Mono.empty();

  }

  @Override
  public Publisher<?> onCallbackQuery(CallbackQueryEvent event) {
    return super.onCallbackQuery(event);
  }
}
```

### å‘½ä»¤å‡½æ•°

#### StartCommandFunction

```java
package com.litongjava.gpt.translator.telegram.function;

import org.reactivestreams.Publisher;
import reactor.core.publisher.Mono;
import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.core.object.Message;
import telegram4j.core.object.chat.Chat;

public class StartCommandFunction {

  public Publisher<? extends Message> apply(SendMessageEvent event) {
    String welcomeMessage = "ğŸŒ **ç¿»è¯‘æœºå™¨äºº** ğŸŒ\n\n è¿™ä¸ªæœºå™¨äººä½¿ç”¨ GPT æŠ€æœ¯ä¸ºæ‚¨æä¾›é«˜è´¨é‡çš„æ–‡æœ¬ç¿»è¯‘æœåŠ¡ã€‚æ¬¢è¿ä½¿ç”¨ç¿»è¯‘æœºå™¨äººï¼\n\n";

    Mono<Chat> chat = event.getMessage().getChat();
    return chat.flatMap(c -> {
      return c.sendMessage(welcomeMessage);
    });
  }
}
```

#### AboutUsCommandFunction

```java
package com.litongjava.gpt.translator.telegram.function;

import org.reactivestreams.Publisher;

import reactor.core.publisher.Mono;
import telegram4j.core.event.domain.message.SendMessageEvent;
import telegram4j.core.object.Message;
import telegram4j.core.object.chat.Chat;

public class AboutUsCommandFunction {

  public Publisher<? extends Message> apply(SendMessageEvent event) {
    String aboutMessage = "**å¼€å‘è€…:** Litong Java\n" + "**ç‰ˆæœ¬:** 1.0.0\n\n" + "æ„Ÿè°¢æ‚¨ä½¿ç”¨æœ¬æœºå™¨äººï¼";
    Mono<Chat> chat = event.getMessage().getChat();
    return chat.flatMap(c -> {
      return c.sendMessage(aboutMessage);
    });
  }
}
```

ä»¥ä¸Šé…ç½®å®Œæˆåï¼Œå‘½ä»¤èœå•çš„æ˜¾ç¤ºæ•ˆæœå¦‚ä¸‹ï¼š

![å‘½ä»¤èœå•æ¼”ç¤º](image-1.png)

## ç»“è®º

é€šè¿‡æœ¬æ–‡æ¡£çš„æŒ‡å¯¼ï¼Œæ‚¨å·²ç»äº†è§£äº†å¦‚ä½•é€šè¿‡ä»£ç ä¸º Telegram æœºå™¨äººæ·»åŠ å’Œç®¡ç†å‘½ä»¤èœå•ï¼Œå¹¶å®ç°äº†å‘½ä»¤æ¶ˆæ¯çš„è¿‡æ»¤å’Œè·¯ç”±å°è£…ã€‚è¿™ä¸ä»…æå‡äº†æœºå™¨äººçš„åŠŸèƒ½æ€§å’Œç”¨æˆ·ä½“éªŒï¼Œè¿˜å¢å¼ºäº†ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ã€‚æ‚¨å¯ä»¥æ ¹æ®éœ€è¦è¿›ä¸€æ­¥æ‰©å±•å‘½ä»¤åŠŸèƒ½ï¼Œæ»¡è¶³ä¸åŒçš„ä¸šåŠ¡éœ€æ±‚ã€‚
