# Tio Boot Handler 文件分片上传

## 服务端实现
```java
package com.litongjava.http.file.server.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 分片上传信息类
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChunkedUploadInfo {
  private String uploadId;
  private String fileName;
  private Long fileSize;
  private Integer totalParts;
  private String repo;
  private String username;
  private Long originalModTime;
  private String tempDirPath;
  private boolean[] receivedParts;

}
```
```java
package com.litongjava.http.file.server.handler;

import java.io.File;
import java.io.RandomAccessFile;
import java.nio.file.Files;
import java.nio.file.attribute.FileTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.alibaba.fastjson2.JSONObject;
import com.litongjava.http.file.server.consts.FileConst;
import com.litongjava.http.file.server.model.ChunkedUploadInfo;
import com.litongjava.jfinal.aop.Aop;
import com.litongjava.model.body.RespBodyVo;
import com.litongjava.tio.boot.admin.services.AppUserService;
import com.litongjava.tio.boot.http.TioRequestContext;
import com.litongjava.tio.http.common.HttpRequest;
import com.litongjava.tio.http.common.HttpResponse;
import com.litongjava.tio.http.common.UploadFile;
import com.litongjava.tio.utils.json.FastJson2Utils;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class FileChunkedUploadHandler {

  // 临时存储上传信息，实际生产环境建议使用Redis等持久化存储
  private static final Map<String, ChunkedUploadInfo> uploadMap = new ConcurrentHashMap<>();

  /**
   * 初始化分片上传
   */
  public HttpResponse initUpload(HttpRequest request) {
    HttpResponse response = TioRequestContext.getResponse();
    String bodyString = request.getBodyString();
    JSONObject jsonObject = FastJson2Utils.parseObject(bodyString);
    try {
      String repo = jsonObject.getString("repo");
      String fileName = jsonObject.getString("file_name");
      Long fileSize = jsonObject.getLong("file_size");
      Integer totalParts = jsonObject.getInteger("total_parts");
      Long originalModTime = jsonObject.getLong("original_mod_time");

      if (repo == null || fileName == null || fileSize == null || totalParts == null) {
        return response.setJson(RespBodyVo.fail("Missing required parameters"));
      }

      String userIdString = request.getUserIdString();
      String username = Aop.get(AppUserService.class).getUsernameById(userIdString);

      // 生成唯一的上传ID
      String uploadId = UUID.randomUUID().toString().replace("-", "");

      // 创建临时目录
      String tempDirPath = FileConst.DATA_DIR + File.separator + username + File.separator + ".temp";
      File tempDir = new File(tempDirPath);
      if (!tempDir.exists()) {
        tempDir.mkdirs();
      }

      // 保存上传信息
      ChunkedUploadInfo uploadInfo = new ChunkedUploadInfo();
      uploadInfo.setUploadId(uploadId);
      uploadInfo.setFileName(fileName);
      uploadInfo.setFileSize(fileSize);
      uploadInfo.setTotalParts(totalParts);
      uploadInfo.setRepo(repo);
      uploadInfo.setUsername(username);
      uploadInfo.setOriginalModTime(originalModTime);
      uploadInfo.setTempDirPath(tempDirPath);
      uploadInfo.setReceivedParts(new boolean[totalParts]);

      uploadMap.put(uploadId, uploadInfo);

      Map<String, Object> data = new HashMap<>();
      data.put("upload_id", uploadId);

      return response.setJson(RespBodyVo.ok(data));

    } catch (Exception e) {
      log.error("Init chunked upload failed", e);
      return response.setJson(RespBodyVo.fail("Init chunked upload failed: " + e.getMessage()));
    }
  }

  /**
   * 上传分片
   */
  public HttpResponse uploadChunk(HttpRequest request) {
    HttpResponse response = TioRequestContext.getResponse();

    try {
      String uploadId = request.getParam("upload_id");
      Integer partIndex = request.getInt("part_index");

      if (uploadId == null || partIndex == null) {
        return response.setJson(RespBodyVo.fail("Missing required parameters"));
      }

      // 获取上传信息
      ChunkedUploadInfo uploadInfo = uploadMap.get(uploadId);
      if (uploadInfo == null) {
        return response.setJson(RespBodyVo.fail("Invalid upload_id"));
      }

      // 检查分片索引是否有效
      if (partIndex < 0 || partIndex >= uploadInfo.getTotalParts()) {
        return response.setJson(RespBodyVo.fail("Invalid part_index"));
      }

      // 获取上传的分片文件
      UploadFile uploadFile = request.getUploadFile("file");
      if (uploadFile == null) {
        return response.setJson(RespBodyVo.fail("Missing file data"));
      }

      // 保存分片到临时文件
      String chunkFileName = uploadId + "_part_" + partIndex;
      File chunkFile = new File(uploadInfo.getTempDirPath() + File.separator + chunkFileName);

      Files.write(chunkFile.toPath(), uploadFile.getData());

      // 标记该分片已接收
      uploadInfo.getReceivedParts()[partIndex] = true;

      Map<String, Object> data = new HashMap<>();
      data.put("part_index", partIndex);
      data.put("upload_id", uploadId);

      return response.setJson(RespBodyVo.ok(data));

    } catch (Exception e) {
      log.error("Upload chunk failed", e);
      return response.setJson(RespBodyVo.fail("Upload chunk failed: " + e.getMessage()));
    }
  }

  /**
   * 完成分片上传
   */
  public HttpResponse completeUpload(HttpRequest request) {
    HttpResponse response = TioRequestContext.getResponse();
    String bodyString = request.getBodyString();
    JSONObject jsonObject = FastJson2Utils.parseObject(bodyString);

    try {
      String uploadId = jsonObject.getString("upload_id");

      if (uploadId == null) {
        return response.setJson(RespBodyVo.fail("Missing upload_id"));
      }

      // 获取上传信息
      ChunkedUploadInfo uploadInfo = uploadMap.get(uploadId);
      if (uploadInfo == null) {
        return response.setJson(RespBodyVo.fail("Invalid upload_id"));
      }

      // 检查所有分片是否都已上传
      boolean allReceived = true;
      for (boolean received : uploadInfo.getReceivedParts()) {
        if (!received) {
          allReceived = false;
          break;
        }
      }

      if (!allReceived) {
        return response.setJson(RespBodyVo.fail("Not all chunks have been uploaded"));
      }

      // 合并所有分片
      String finalFilePath = FileConst.DATA_DIR + File.separator + uploadInfo.getUsername() + File.separator
          + uploadInfo.getRepo() + File.separator + uploadInfo.getFileName();

      File finalFile = new File(finalFilePath);
      File parentFile = finalFile.getParentFile();
      if (!parentFile.exists()) {
        parentFile.mkdirs();
      }

      // 使用RandomAccessFile进行文件合并
      try (RandomAccessFile raf = new RandomAccessFile(finalFile, "rw")) {
        for (int i = 0; i < uploadInfo.getTotalParts(); i++) {
          String chunkFileName = uploadId + "_part_" + i;
          File chunkFile = new File(uploadInfo.getTempDirPath() + File.separator + chunkFileName);

          if (chunkFile.exists()) {
            byte[] chunkData = Files.readAllBytes(chunkFile.toPath());
            raf.write(chunkData);
            // 删除临时分片文件
            chunkFile.delete();
          }
        }
      }

      // 设置文件的最后修改时间
      if (uploadInfo.getOriginalModTime() != null && uploadInfo.getOriginalModTime() > 0) {
        FileTime fileTime = FileTime.fromMillis(uploadInfo.getOriginalModTime() * 1000);
        Files.setLastModifiedTime(finalFile.toPath(), fileTime);
      }

      // 清理上传信息
      uploadMap.remove(uploadId);

      // 删除临时目录（如果为空）
      File tempDir = new File(uploadInfo.getTempDirPath());
      if (tempDir.exists() && tempDir.list().length == 0) {
        tempDir.delete();
      }

      Map<String, Object> data = new HashMap<>();
      data.put("file_path", finalFilePath);
      data.put("file_name", uploadInfo.getFileName());

      return response.setJson(RespBodyVo.ok(data));

    } catch (Exception e) {
      log.error("Complete chunked upload failed", e);
      return response.setJson(RespBodyVo.fail("Complete chunked upload failed: " + e.getMessage()));
    }
  }

}
```

客户端实现

```go
type ChunkUploadResponse struct {
  PartIndex  int    `json:"part_index"`
  UploadID   string `json:"upload_id,omitempty"`
  ETag       string `json:"etag,omitempty"`
  IsComplete bool   `json:"is_complete,omitempty"`
}
```

```go
package client

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/litongjava/hfile/model"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"strconv"
)

// 支持上传ID的分片上传
func UploadInChunks(serverURL, token, repo, filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	fileInfo, err := file.Stat()
	if err != nil {
		return fmt.Errorf("failed to get file info: %w", err)
	}

	fileSize := fileInfo.Size()
	totalParts := int((fileSize + ChunkSize - 1) / ChunkSize)
	modTime := fileInfo.ModTime().Unix()

	hlog.Infof("Start chunk upload: file=%s, size=%d, chunks=%d", filePath, fileSize, totalParts)

	// 1. 初始化分片上传，获取upload_id
	uploadID, err := initChunkedUpload(serverURL, token, repo, filePath, fileSize, totalParts, modTime)
	if err != nil {
		return fmt.Errorf("failed to init chunked upload: %w", err)
	}

	// 2. 逐个上传分片
	for partIndex := 0; partIndex < totalParts; partIndex++ {
		start := int64(partIndex) * ChunkSize
		end := start + ChunkSize
		if end > fileSize {
			end = fileSize
		}

		chunk := make([]byte, end-start)
		_, err := file.ReadAt(chunk, start)
		if err != nil && err != io.EOF {
			return fmt.Errorf("failed to read chunk %d: %w", partIndex, err)
		}

		err = uploadChunk(serverURL, token, repo, uploadID, partIndex, chunk, filePath)
		if err != nil {
			return fmt.Errorf("failed to upload chunk %d: %w", partIndex, err)
		}

		hlog.Infof("Chunk %d/%d uploaded successfully", partIndex+1, totalParts)
	}

	// 3. 完成分片上传
	err = completeChunkedUpload(serverURL, token, repo, uploadID)
	if err != nil {
		return fmt.Errorf("failed to complete chunked upload: %w", err)
	}

	hlog.Infof("All chunks uploaded and merged successfully for file: %s", filePath)
	return nil
}

// 初始化分片上传
func initChunkedUpload(serverURL, token, repo, fileName string, fileSize int64, totalParts int, modTime int64) (string, error) {
	url := fmt.Sprintf("%s/file/upload/init?repo=%s", serverURL, repo)

	reqBody := map[string]interface{}{
		"repo":              repo,
		"file_name":         fileName,
		"file_size":         fileSize,
		"total_parts":       totalParts,
		"original_mod_time": modTime,
	}

	jsonData, _ := json.Marshal(reqBody)

	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("init failed with status %d: %s", resp.StatusCode, string(body))
	}

	var apiResp model.APIResponse
	json.Unmarshal(body, &apiResp)

	if !apiResp.Ok {
		return "", fmt.Errorf("init failed: %s", *apiResp.Msg)
	}

	data, ok := apiResp.Data.(map[string]interface{})
	if !ok {
		return "", fmt.Errorf("invalid init response format")
	}

	uploadID, ok := data["upload_id"].(string)
	if !ok {
		return "", fmt.Errorf("upload_id not found in response")
	}

	return uploadID, nil
}

// 上传单个分片
func uploadChunk(serverURL, token, repo, uploadID string, partIndex int, chunk []byte, fileName string) error {
	url := fmt.Sprintf("%s/file/upload/chunk?repo=%s", serverURL, repo)

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, err := writer.CreateFormFile("file", fileName)
	if err != nil {
		return err
	}
	_, err = part.Write(chunk)
	if err != nil {
		return err
	}

	_ = writer.WriteField("upload_id", uploadID)
	_ = writer.WriteField("part_index", strconv.Itoa(partIndex))
	writer.Close()

	req, _ := http.NewRequest("POST", url, body)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("Authorization", "Bearer "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("chunk upload failed with status %d: %s", resp.StatusCode, string(respBody))
	}

	var apiResp model.APIResponse
	json.Unmarshal(respBody, &apiResp)

	if !apiResp.Ok {
		return fmt.Errorf("chunk upload failed: %s", *apiResp.Msg)
	}

	return nil
}

// 完成分片上传
func completeChunkedUpload(serverURL, token, repo, uploadID string) error {
	url := fmt.Sprintf("%s/file/upload/complete?repo=%s", serverURL, repo)

	reqBody := map[string]interface{}{
		"upload_id": uploadID,
	}

	jsonData, _ := json.Marshal(reqBody)

	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("complete failed with status %d: %s", resp.StatusCode, string(body))
	}

	var apiResp model.APIResponse
	json.Unmarshal(body, &apiResp)

	if !apiResp.Ok {
		return fmt.Errorf("complete failed: %s", *apiResp.Msg)
	}

	return nil
}

```